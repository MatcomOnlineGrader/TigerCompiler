//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g 2015-03-04 22:02:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System;
	using System.Collections;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  TigerCompiler.Parsing 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class TigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALIAS_TYPE", "AND", "ARRAY", "ARRAY_TYPE", "ASCII", "ASSIGN", "BLOCK_DECLARATIONS", "BREAK", "CALL", "COLON", "COMMA", "DIGIT", "DIV", "DO", "ELSE", "END", "EQ", "EXPRESSIONS_BLOCK", "FIELD_TYPE", "FIELD_VALUE", "FOR", "FUNCTION", "FUNCTIONS_BLOCK", "FUNCTION_DECLARATION", "GETHAN", "GTHAN", "ID", "IF", "IF_THEN", "IF_THEN_ELSE", "IN", "INT", "LCB", "LET", "LETHAN", "LETINEND", "LETTER", "LP", "LSB", "LTHAN", "MINUS", "ML_COMMENTS", "NEGATIVE", "NIL", "NOTEQ", "OF", "OR", "PARAMETERS", "PCHAR", "PERIOD", "PLUS", "PROGRAM", "RCB", "RECORD", "RECORD_TYPE", "RP", "RSB", "SEMI", "STAR", "STRING", "THEN", "TO", "TYPE", "TYPES_BLOCK", "TYPE_DECLARATION", "USCORE", "VAR", "VARIABLES_BLOCK", "VARIABLE_DECLARATION", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ALIAS_TYPE=4;
	public const int AND=5;
	public const int ARRAY=6;
	public const int ARRAY_TYPE=7;
	public const int ASCII=8;
	public const int ASSIGN=9;
	public const int BLOCK_DECLARATIONS=10;
	public const int BREAK=11;
	public const int CALL=12;
	public const int COLON=13;
	public const int COMMA=14;
	public const int DIGIT=15;
	public const int DIV=16;
	public const int DO=17;
	public const int ELSE=18;
	public const int END=19;
	public const int EQ=20;
	public const int EXPRESSIONS_BLOCK=21;
	public const int FIELD_TYPE=22;
	public const int FIELD_VALUE=23;
	public const int FOR=24;
	public const int FUNCTION=25;
	public const int FUNCTIONS_BLOCK=26;
	public const int FUNCTION_DECLARATION=27;
	public const int GETHAN=28;
	public const int GTHAN=29;
	public const int ID=30;
	public const int IF=31;
	public const int IF_THEN=32;
	public const int IF_THEN_ELSE=33;
	public const int IN=34;
	public const int INT=35;
	public const int LCB=36;
	public const int LET=37;
	public const int LETHAN=38;
	public const int LETINEND=39;
	public const int LETTER=40;
	public const int LP=41;
	public const int LSB=42;
	public const int LTHAN=43;
	public const int MINUS=44;
	public const int ML_COMMENTS=45;
	public const int NEGATIVE=46;
	public const int NIL=47;
	public const int NOTEQ=48;
	public const int OF=49;
	public const int OR=50;
	public const int PARAMETERS=51;
	public const int PCHAR=52;
	public const int PERIOD=53;
	public const int PLUS=54;
	public const int PROGRAM=55;
	public const int RCB=56;
	public const int RECORD=57;
	public const int RECORD_TYPE=58;
	public const int RP=59;
	public const int RSB=60;
	public const int SEMI=61;
	public const int STAR=62;
	public const int STRING=63;
	public const int THEN=64;
	public const int TO=65;
	public const int TYPE=66;
	public const int TYPES_BLOCK=67;
	public const int TYPE_DECLARATION=68;
	public const int USCORE=69;
	public const int VAR=70;
	public const int VARIABLES_BLOCK=71;
	public const int VARIABLE_DECLARATION=72;
	public const int WHILE=73;
	public const int WS=74;

	public TigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return TigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g"; } }


	    public override void ReportError(RecognitionException exc) 
	    {
	        throw new ParsingException(GetErrorMessage(exc, TokenNames), exc);
	    }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:172:8: public program : x= expror EOF -> ^( PROGRAM $x) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF1 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);

		object EOF1_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_expror=new RewriteRuleSubtreeStream(adaptor,"rule expror");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(172, 34);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:173:2: (x= expror EOF -> ^( PROGRAM $x) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:173:4: x= expror EOF
			{
			DebugLocation(173, 6);
			PushFollow(Follow._expror_in_program1066);
			x=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expror.Add(x.Tree);
			DebugLocation(173, 15);
			EOF1=(IToken)Match(input,EOF,Follow._EOF_in_program1068); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF1);



			{
			// AST REWRITE
			// elements: x
			// token labels: 
			// rule labels: retval, x
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 173:19: -> ^( PROGRAM $x)
			{
				DebugLocation(173, 22);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:173:22: ^( PROGRAM $x)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(173, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(173, 33);
				adaptor.AddChild(root_1, stream_x.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(173, 34);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_expression_sequence();
	partial void LeaveRule_expression_sequence();

	// $ANTLR start "expression_sequence"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:175:1: expression_sequence : expror ( SEMI ! expror )* ;
	[GrammarRule("expression_sequence")]
	private AstParserRuleReturnScope<object, IToken> expression_sequence()
	{
		EnterRule_expression_sequence();
		EnterRule("expression_sequence", 2);
		TraceIn("expression_sequence", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI3 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expror2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expror4 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI3_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expression_sequence");
		DebugLocation(175, 25);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:176:2: ( expror ( SEMI ! expror )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:176:4: expror ( SEMI ! expror )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(176, 4);
			PushFollow(Follow._expror_in_expression_sequence1086);
			expror2=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror2.Tree);
			DebugLocation(176, 11);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:176:11: ( SEMI ! expror )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==SEMI))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:176:12: SEMI ! expror
					{
					DebugLocation(176, 16);
					SEMI3=(IToken)Match(input,SEMI,Follow._SEMI_in_expression_sequence1089); if (state.failed) return retval;
					DebugLocation(176, 18);
					PushFollow(Follow._expror_in_expression_sequence1092);
					expror4=expror();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expror4.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression_sequence", 2);
			LeaveRule("expression_sequence", 2);
			LeaveRule_expression_sequence();
		}
		DebugLocation(176, 25);
		} finally { DebugExitRule(GrammarFileName, "expression_sequence"); }
		return retval;

	}
	// $ANTLR end "expression_sequence"

	partial void EnterRule_expror();
	partial void LeaveRule_expror();

	// $ANTLR start "expror"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:178:1: expror : (x= exprand -> $x) ( options {greedy=true; } : OR y= exprand -> ^( OR $expror $y) )* ;
	[GrammarRule("expror")]
	private AstParserRuleReturnScope<object, IToken> expror()
	{
		EnterRule_expror();
		EnterRule("expror", 3);
		TraceIn("expror", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);

		object OR5_tree = default(object);
		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_exprand=new RewriteRuleSubtreeStream(adaptor,"rule exprand");
		try { DebugEnterRule(GrammarFileName, "expror");
		DebugLocation(178, 86);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:2: ( (x= exprand -> $x) ( options {greedy=true; } : OR y= exprand -> ^( OR $expror $y) )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:4: (x= exprand -> $x) ( options {greedy=true; } : OR y= exprand -> ^( OR $expror $y) )*
			{
			DebugLocation(179, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:4: (x= exprand -> $x)
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:5: x= exprand
			{
			DebugLocation(179, 7);
			PushFollow(Follow._exprand_in_expror1108);
			x=exprand();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exprand.Add(x.Tree);


			{
			// AST REWRITE
			// elements: x
			// token labels: 
			// rule labels: retval, x
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 179:17: -> $x
			{
				DebugLocation(179, 21);
				adaptor.AddChild(root_0, stream_x.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(179, 24);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:24: ( options {greedy=true; } : OR y= exprand -> ^( OR $expror $y) )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==OR))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:51: OR y= exprand
					{
					DebugLocation(179, 51);
					OR5=(IToken)Match(input,OR,Follow._OR_in_expror1128); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_OR.Add(OR5);

					DebugLocation(179, 56);
					PushFollow(Follow._exprand_in_expror1134);
					y=exprand();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_exprand.Add(y.Tree);


					{
					// AST REWRITE
					// elements: expror, y, OR
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 179:66: -> ^( OR $expror $y)
					{
						DebugLocation(179, 69);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:179:69: ^( OR $expror $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(179, 71);
						root_1 = (object)adaptor.BecomeRoot(stream_OR.NextNode(), root_1);

						DebugLocation(179, 75);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(179, 83);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expror", 3);
			LeaveRule("expror", 3);
			LeaveRule_expror();
		}
		DebugLocation(179, 86);
		} finally { DebugExitRule(GrammarFileName, "expror"); }
		return retval;

	}
	// $ANTLR end "expror"

	partial void EnterRule_exprand();
	partial void LeaveRule_exprand();

	// $ANTLR start "exprand"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:181:1: exprand : (x= exprrel -> $x) ( options {greedy=true; } : AND y= exprrel -> ^( AND $exprand $y) )* ;
	[GrammarRule("exprand")]
	private AstParserRuleReturnScope<object, IToken> exprand()
	{
		EnterRule_exprand();
		EnterRule("exprand", 4);
		TraceIn("exprand", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND6 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);

		object AND6_tree = default(object);
		RewriteRuleITokenStream stream_AND=new RewriteRuleITokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_exprrel=new RewriteRuleSubtreeStream(adaptor,"rule exprrel");
		try { DebugEnterRule(GrammarFileName, "exprand");
		DebugLocation(181, 89);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:2: ( (x= exprrel -> $x) ( options {greedy=true; } : AND y= exprrel -> ^( AND $exprand $y) )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:4: (x= exprrel -> $x) ( options {greedy=true; } : AND y= exprrel -> ^( AND $exprand $y) )*
			{
			DebugLocation(182, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:4: (x= exprrel -> $x)
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:5: x= exprrel
			{
			DebugLocation(182, 7);
			PushFollow(Follow._exprrel_in_exprand1162);
			x=exprrel();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_exprrel.Add(x.Tree);


			{
			// AST REWRITE
			// elements: x
			// token labels: 
			// rule labels: retval, x
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 182:17: -> $x
			{
				DebugLocation(182, 21);
				adaptor.AddChild(root_0, stream_x.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(182, 24);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:24: ( options {greedy=true; } : AND y= exprrel -> ^( AND $exprand $y) )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==AND))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:51: AND y= exprrel
					{
					DebugLocation(182, 51);
					AND6=(IToken)Match(input,AND,Follow._AND_in_exprand1182); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_AND.Add(AND6);

					DebugLocation(182, 57);
					PushFollow(Follow._exprrel_in_exprand1188);
					y=exprrel();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_exprrel.Add(y.Tree);


					{
					// AST REWRITE
					// elements: y, exprand, AND
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 182:67: -> ^( AND $exprand $y)
					{
						DebugLocation(182, 70);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:182:70: ^( AND $exprand $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(182, 72);
						root_1 = (object)adaptor.BecomeRoot(stream_AND.NextNode(), root_1);

						DebugLocation(182, 77);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(182, 86);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprand", 4);
			LeaveRule("exprand", 4);
			LeaveRule_exprand();
		}
		DebugLocation(182, 89);
		} finally { DebugExitRule(GrammarFileName, "exprand"); }
		return retval;

	}
	// $ANTLR end "exprand"

	partial void EnterRule_exprrel();
	partial void LeaveRule_exprrel();

	// $ANTLR start "exprrel"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:184:1: exprrel : (x= arith -> $x) ( options {greedy=true; } : ( EQ y= arith -> ^( EQ $x $y) | NOTEQ y= arith -> ^( NOTEQ $x $y) | LETHAN y= arith -> ^( LETHAN $x $y) | GETHAN y= arith -> ^( GETHAN $x $y) | LTHAN y= arith -> ^( LTHAN $x $y) | GTHAN y= arith -> ^( GTHAN $x $y) ) )? ;
	[GrammarRule("exprrel")]
	private AstParserRuleReturnScope<object, IToken> exprrel()
	{
		EnterRule_exprrel();
		EnterRule("exprrel", 5);
		TraceIn("exprrel", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQ7 = default(IToken);
		IToken NOTEQ8 = default(IToken);
		IToken LETHAN9 = default(IToken);
		IToken GETHAN10 = default(IToken);
		IToken LTHAN11 = default(IToken);
		IToken GTHAN12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);

		object EQ7_tree = default(object);
		object NOTEQ8_tree = default(object);
		object LETHAN9_tree = default(object);
		object GETHAN10_tree = default(object);
		object LTHAN11_tree = default(object);
		object GTHAN12_tree = default(object);
		RewriteRuleITokenStream stream_LETHAN=new RewriteRuleITokenStream(adaptor,"token LETHAN");
		RewriteRuleITokenStream stream_LTHAN=new RewriteRuleITokenStream(adaptor,"token LTHAN");
		RewriteRuleITokenStream stream_NOTEQ=new RewriteRuleITokenStream(adaptor,"token NOTEQ");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_GETHAN=new RewriteRuleITokenStream(adaptor,"token GETHAN");
		RewriteRuleITokenStream stream_GTHAN=new RewriteRuleITokenStream(adaptor,"token GTHAN");
		RewriteRuleSubtreeStream stream_arith=new RewriteRuleSubtreeStream(adaptor,"rule arith");
		try { DebugEnterRule(GrammarFileName, "exprrel");
		DebugLocation(184, 1);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:185:2: ( (x= arith -> $x) ( options {greedy=true; } : ( EQ y= arith -> ^( EQ $x $y) | NOTEQ y= arith -> ^( NOTEQ $x $y) | LETHAN y= arith -> ^( LETHAN $x $y) | GETHAN y= arith -> ^( GETHAN $x $y) | LTHAN y= arith -> ^( LTHAN $x $y) | GTHAN y= arith -> ^( GTHAN $x $y) ) )? )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:185:4: (x= arith -> $x) ( options {greedy=true; } : ( EQ y= arith -> ^( EQ $x $y) | NOTEQ y= arith -> ^( NOTEQ $x $y) | LETHAN y= arith -> ^( LETHAN $x $y) | GETHAN y= arith -> ^( GETHAN $x $y) | LTHAN y= arith -> ^( LTHAN $x $y) | GTHAN y= arith -> ^( GTHAN $x $y) ) )?
			{
			DebugLocation(185, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:185:4: (x= arith -> $x)
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:185:5: x= arith
			{
			DebugLocation(185, 7);
			PushFollow(Follow._arith_in_exprrel1216);
			x=arith();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arith.Add(x.Tree);


			{
			// AST REWRITE
			// elements: x
			// token labels: 
			// rule labels: retval, x
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 185:15: -> $x
			{
				DebugLocation(185, 19);
				adaptor.AddChild(root_0, stream_x.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(185, 22);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:185:22: ( options {greedy=true; } : ( EQ y= arith -> ^( EQ $x $y) | NOTEQ y= arith -> ^( NOTEQ $x $y) | LETHAN y= arith -> ^( LETHAN $x $y) | GETHAN y= arith -> ^( GETHAN $x $y) | LTHAN y= arith -> ^( LTHAN $x $y) | GTHAN y= arith -> ^( GTHAN $x $y) ) )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case EQ:
				{
				alt5 = 1;
				}
				break;
			case NOTEQ:
				{
				alt5 = 1;
				}
				break;
			case LETHAN:
				{
				alt5 = 1;
				}
				break;
			case GETHAN:
				{
				alt5 = 1;
				}
				break;
			case LTHAN:
				{
				alt5 = 1;
				}
				break;
			case GTHAN:
				{
				alt5 = 1;
				}
				break;
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:186:4: ( EQ y= arith -> ^( EQ $x $y) | NOTEQ y= arith -> ^( NOTEQ $x $y) | LETHAN y= arith -> ^( LETHAN $x $y) | GETHAN y= arith -> ^( GETHAN $x $y) | LTHAN y= arith -> ^( LTHAN $x $y) | GTHAN y= arith -> ^( GTHAN $x $y) )
				{
				DebugLocation(186, 4);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:186:4: ( EQ y= arith -> ^( EQ $x $y) | NOTEQ y= arith -> ^( NOTEQ $x $y) | LETHAN y= arith -> ^( LETHAN $x $y) | GETHAN y= arith -> ^( GETHAN $x $y) | LTHAN y= arith -> ^( LTHAN $x $y) | GTHAN y= arith -> ^( GTHAN $x $y) )
				int alt4=6;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				switch (input.LA(1))
				{
				case EQ:
					{
					alt4 = 1;
					}
					break;
				case NOTEQ:
					{
					alt4 = 2;
					}
					break;
				case LETHAN:
					{
					alt4 = 3;
					}
					break;
				case GETHAN:
					{
					alt4 = 4;
					}
					break;
				case LTHAN:
					{
					alt4 = 5;
					}
					break;
				case GTHAN:
					{
					alt4 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:186:5: EQ y= arith
					{
					DebugLocation(186, 5);
					EQ7=(IToken)Match(input,EQ,Follow._EQ_in_exprrel1240); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EQ.Add(EQ7);

					DebugLocation(186, 14);
					PushFollow(Follow._arith_in_exprrel1250);
					y=arith();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arith.Add(y.Tree);


					{
					// AST REWRITE
					// elements: EQ, y, x
					// token labels: 
					// rule labels: retval, y, x
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 186:22: -> ^( EQ $x $y)
					{
						DebugLocation(186, 25);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:186:25: ^( EQ $x $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(186, 27);
						root_1 = (object)adaptor.BecomeRoot(stream_EQ.NextNode(), root_1);

						DebugLocation(186, 35);
						adaptor.AddChild(root_1, stream_x.NextTree());
						DebugLocation(186, 38);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:187:5: NOTEQ y= arith
					{
					DebugLocation(187, 5);
					NOTEQ8=(IToken)Match(input,NOTEQ,Follow._NOTEQ_in_exprrel1272); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_NOTEQ.Add(NOTEQ8);

					DebugLocation(187, 14);
					PushFollow(Follow._arith_in_exprrel1279);
					y=arith();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arith.Add(y.Tree);


					{
					// AST REWRITE
					// elements: y, x, NOTEQ
					// token labels: 
					// rule labels: retval, y, x
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 187:22: -> ^( NOTEQ $x $y)
					{
						DebugLocation(187, 25);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:187:25: ^( NOTEQ $x $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(187, 27);
						root_1 = (object)adaptor.BecomeRoot(stream_NOTEQ.NextNode(), root_1);

						DebugLocation(187, 35);
						adaptor.AddChild(root_1, stream_x.NextTree());
						DebugLocation(187, 38);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:188:5: LETHAN y= arith
					{
					DebugLocation(188, 5);
					LETHAN9=(IToken)Match(input,LETHAN,Follow._LETHAN_in_exprrel1298); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LETHAN.Add(LETHAN9);

					DebugLocation(188, 14);
					PushFollow(Follow._arith_in_exprrel1304);
					y=arith();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arith.Add(y.Tree);


					{
					// AST REWRITE
					// elements: y, x, LETHAN
					// token labels: 
					// rule labels: retval, y, x
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 188:22: -> ^( LETHAN $x $y)
					{
						DebugLocation(188, 25);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:188:25: ^( LETHAN $x $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(188, 27);
						root_1 = (object)adaptor.BecomeRoot(stream_LETHAN.NextNode(), root_1);

						DebugLocation(188, 35);
						adaptor.AddChild(root_1, stream_x.NextTree());
						DebugLocation(188, 38);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:189:5: GETHAN y= arith
					{
					DebugLocation(189, 5);
					GETHAN10=(IToken)Match(input,GETHAN,Follow._GETHAN_in_exprrel1322); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_GETHAN.Add(GETHAN10);

					DebugLocation(189, 14);
					PushFollow(Follow._arith_in_exprrel1328);
					y=arith();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arith.Add(y.Tree);


					{
					// AST REWRITE
					// elements: x, y, GETHAN
					// token labels: 
					// rule labels: retval, y, x
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 189:22: -> ^( GETHAN $x $y)
					{
						DebugLocation(189, 25);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:189:25: ^( GETHAN $x $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(189, 27);
						root_1 = (object)adaptor.BecomeRoot(stream_GETHAN.NextNode(), root_1);

						DebugLocation(189, 35);
						adaptor.AddChild(root_1, stream_x.NextTree());
						DebugLocation(189, 38);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:190:5: LTHAN y= arith
					{
					DebugLocation(190, 5);
					LTHAN11=(IToken)Match(input,LTHAN,Follow._LTHAN_in_exprrel1346); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LTHAN.Add(LTHAN11);

					DebugLocation(190, 14);
					PushFollow(Follow._arith_in_exprrel1353);
					y=arith();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arith.Add(y.Tree);


					{
					// AST REWRITE
					// elements: y, x, LTHAN
					// token labels: 
					// rule labels: retval, y, x
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 190:22: -> ^( LTHAN $x $y)
					{
						DebugLocation(190, 25);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:190:25: ^( LTHAN $x $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(190, 27);
						root_1 = (object)adaptor.BecomeRoot(stream_LTHAN.NextNode(), root_1);

						DebugLocation(190, 35);
						adaptor.AddChild(root_1, stream_x.NextTree());
						DebugLocation(190, 38);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:191:5: GTHAN y= arith
					{
					DebugLocation(191, 5);
					GTHAN12=(IToken)Match(input,GTHAN,Follow._GTHAN_in_exprrel1372); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_GTHAN.Add(GTHAN12);

					DebugLocation(191, 14);
					PushFollow(Follow._arith_in_exprrel1379);
					y=arith();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arith.Add(y.Tree);


					{
					// AST REWRITE
					// elements: GTHAN, y, x
					// token labels: 
					// rule labels: retval, y, x
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
					RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 191:22: -> ^( GTHAN $x $y)
					{
						DebugLocation(191, 25);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:191:25: ^( GTHAN $x $y)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(191, 27);
						root_1 = (object)adaptor.BecomeRoot(stream_GTHAN.NextNode(), root_1);

						DebugLocation(191, 35);
						adaptor.AddChild(root_1, stream_x.NextTree());
						DebugLocation(191, 38);
						adaptor.AddChild(root_1, stream_y.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(4); }


				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exprrel", 5);
			LeaveRule("exprrel", 5);
			LeaveRule_exprrel();
		}
		DebugLocation(193, 1);
		} finally { DebugExitRule(GrammarFileName, "exprrel"); }
		return retval;

	}
	// $ANTLR end "exprrel"

	partial void EnterRule_arith();
	partial void LeaveRule_arith();

	// $ANTLR start "arith"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:195:1: arith : (x= term -> $x) ( options {greedy=true; } : ( MINUS y= term -> ^( MINUS $arith $y) | PLUS z= term -> ^( PLUS $arith $z) ) )* ;
	[GrammarRule("arith")]
	private AstParserRuleReturnScope<object, IToken> arith()
	{
		EnterRule_arith();
		EnterRule("arith", 6);
		TraceIn("arith", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MINUS13 = default(IToken);
		IToken PLUS14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> z = default(AstParserRuleReturnScope<object, IToken>);

		object MINUS13_tree = default(object);
		object PLUS14_tree = default(object);
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		try { DebugEnterRule(GrammarFileName, "arith");
		DebugLocation(195, 1);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:196:2: ( (x= term -> $x) ( options {greedy=true; } : ( MINUS y= term -> ^( MINUS $arith $y) | PLUS z= term -> ^( PLUS $arith $z) ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:196:4: (x= term -> $x) ( options {greedy=true; } : ( MINUS y= term -> ^( MINUS $arith $y) | PLUS z= term -> ^( PLUS $arith $z) ) )*
			{
			DebugLocation(196, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:196:4: (x= term -> $x)
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:196:5: x= term
			{
			DebugLocation(196, 7);
			PushFollow(Follow._term_in_arith1417);
			x=term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_term.Add(x.Tree);


			{
			// AST REWRITE
			// elements: x
			// token labels: 
			// rule labels: retval, x
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 196:14: -> $x
			{
				DebugLocation(196, 18);
				adaptor.AddChild(root_0, stream_x.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(196, 21);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:196:21: ( options {greedy=true; } : ( MINUS y= term -> ^( MINUS $arith $y) | PLUS z= term -> ^( PLUS $arith $z) ) )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==MINUS))
				{
					alt7 = 1;
				}
				else if ((LA7_0==PLUS))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:197:4: ( MINUS y= term -> ^( MINUS $arith $y) | PLUS z= term -> ^( PLUS $arith $z) )
					{
					DebugLocation(197, 4);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:197:4: ( MINUS y= term -> ^( MINUS $arith $y) | PLUS z= term -> ^( PLUS $arith $z) )
					int alt6=2;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==MINUS))
					{
						alt6 = 1;
					}
					else if ((LA6_0==PLUS))
					{
						alt6 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:197:6: MINUS y= term
						{
						DebugLocation(197, 6);
						MINUS13=(IToken)Match(input,MINUS,Follow._MINUS_in_arith1442); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_MINUS.Add(MINUS13);

						DebugLocation(197, 14);
						PushFollow(Follow._term_in_arith1448);
						y=term();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_term.Add(y.Tree);


						{
						// AST REWRITE
						// elements: MINUS, y, arith
						// token labels: 
						// rule labels: retval, y
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
						RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);

						root_0 = (object)adaptor.Nil();
						// 197:21: -> ^( MINUS $arith $y)
						{
							DebugLocation(197, 24);
							// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:197:24: ^( MINUS $arith $y)
							{
							object root_1 = (object)adaptor.Nil();
							DebugLocation(197, 26);
							root_1 = (object)adaptor.BecomeRoot(stream_MINUS.NextNode(), root_1);

							DebugLocation(197, 33);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(197, 40);
							adaptor.AddChild(root_1, stream_y.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:198:6: PLUS z= term
						{
						DebugLocation(198, 6);
						PLUS14=(IToken)Match(input,PLUS,Follow._PLUS_in_arith1467); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_PLUS.Add(PLUS14);

						DebugLocation(198, 14);
						PushFollow(Follow._term_in_arith1474);
						z=term();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_term.Add(z.Tree);


						{
						// AST REWRITE
						// elements: z, arith, PLUS
						// token labels: 
						// rule labels: retval, z
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
						RewriteRuleSubtreeStream stream_z=new RewriteRuleSubtreeStream(adaptor,"rule z",z!=null?z.Tree:null);

						root_0 = (object)adaptor.Nil();
						// 198:21: -> ^( PLUS $arith $z)
						{
							DebugLocation(198, 24);
							// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:198:24: ^( PLUS $arith $z)
							{
							object root_1 = (object)adaptor.Nil();
							DebugLocation(198, 26);
							root_1 = (object)adaptor.BecomeRoot(stream_PLUS.NextNode(), root_1);

							DebugLocation(198, 33);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(198, 40);
							adaptor.AddChild(root_1, stream_z.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					}
					} finally { DebugExitSubRule(6); }


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arith", 6);
			LeaveRule("arith", 6);
			LeaveRule_arith();
		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "arith"); }
		return retval;

	}
	// $ANTLR end "arith"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:202:1: term : (x= fact -> $x) ( options {greedy=true; } : ( STAR y= fact -> ^( STAR $term $y) | DIV z= fact -> ^( DIV $term $z) ) )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 7);
		TraceIn("term", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STAR15 = default(IToken);
		IToken DIV16 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> z = default(AstParserRuleReturnScope<object, IToken>);

		object STAR15_tree = default(object);
		object DIV16_tree = default(object);
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_DIV=new RewriteRuleITokenStream(adaptor,"token DIV");
		RewriteRuleSubtreeStream stream_fact=new RewriteRuleSubtreeStream(adaptor,"rule fact");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(202, 1);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:203:2: ( (x= fact -> $x) ( options {greedy=true; } : ( STAR y= fact -> ^( STAR $term $y) | DIV z= fact -> ^( DIV $term $z) ) )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:203:4: (x= fact -> $x) ( options {greedy=true; } : ( STAR y= fact -> ^( STAR $term $y) | DIV z= fact -> ^( DIV $term $z) ) )*
			{
			DebugLocation(203, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:203:4: (x= fact -> $x)
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:203:5: x= fact
			{
			DebugLocation(203, 7);
			PushFollow(Follow._fact_in_term1510);
			x=fact();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fact.Add(x.Tree);


			{
			// AST REWRITE
			// elements: x
			// token labels: 
			// rule labels: retval, x
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 203:14: -> $x
			{
				DebugLocation(203, 18);
				adaptor.AddChild(root_0, stream_x.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(203, 21);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:203:21: ( options {greedy=true; } : ( STAR y= fact -> ^( STAR $term $y) | DIV z= fact -> ^( DIV $term $z) ) )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==STAR))
				{
					alt9 = 1;
				}
				else if ((LA9_0==DIV))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:204:5: ( STAR y= fact -> ^( STAR $term $y) | DIV z= fact -> ^( DIV $term $z) )
					{
					DebugLocation(204, 5);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:204:5: ( STAR y= fact -> ^( STAR $term $y) | DIV z= fact -> ^( DIV $term $z) )
					int alt8=2;
					try { DebugEnterSubRule(8);
					try { DebugEnterDecision(8, false);
					int LA8_0 = input.LA(1);

					if ((LA8_0==STAR))
					{
						alt8 = 1;
					}
					else if ((LA8_0==DIV))
					{
						alt8 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(8); }
					switch (alt8)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:204:7: STAR y= fact
						{
						DebugLocation(204, 7);
						STAR15=(IToken)Match(input,STAR,Follow._STAR_in_term1536); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_STAR.Add(STAR15);

						DebugLocation(204, 14);
						PushFollow(Follow._fact_in_term1542);
						y=fact();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_fact.Add(y.Tree);


						{
						// AST REWRITE
						// elements: term, STAR, y
						// token labels: 
						// rule labels: retval, y
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
						RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);

						root_0 = (object)adaptor.Nil();
						// 204:21: -> ^( STAR $term $y)
						{
							DebugLocation(204, 24);
							// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:204:24: ^( STAR $term $y)
							{
							object root_1 = (object)adaptor.Nil();
							DebugLocation(204, 26);
							root_1 = (object)adaptor.BecomeRoot(stream_STAR.NextNode(), root_1);

							DebugLocation(204, 32);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(204, 38);
							adaptor.AddChild(root_1, stream_y.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:205:7: DIV z= fact
						{
						DebugLocation(205, 7);
						DIV16=(IToken)Match(input,DIV,Follow._DIV_in_term1562); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_DIV.Add(DIV16);

						DebugLocation(205, 14);
						PushFollow(Follow._fact_in_term1569);
						z=fact();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_fact.Add(z.Tree);


						{
						// AST REWRITE
						// elements: z, DIV, term
						// token labels: 
						// rule labels: retval, z
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
						RewriteRuleSubtreeStream stream_z=new RewriteRuleSubtreeStream(adaptor,"rule z",z!=null?z.Tree:null);

						root_0 = (object)adaptor.Nil();
						// 205:21: -> ^( DIV $term $z)
						{
							DebugLocation(205, 24);
							// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:205:24: ^( DIV $term $z)
							{
							object root_1 = (object)adaptor.Nil();
							DebugLocation(205, 26);
							root_1 = (object)adaptor.BecomeRoot(stream_DIV.NextNode(), root_1);

							DebugLocation(205, 32);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(205, 38);
							adaptor.AddChild(root_1, stream_z.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					}
					} finally { DebugExitSubRule(8); }


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 7);
			LeaveRule("term", 7);
			LeaveRule_term();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_fact();
	partial void LeaveRule_fact();

	// $ANTLR start "fact"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:209:1: fact : ( atom | MINUS x= fact -> ^( NEGATIVE $x) );
	[GrammarRule("fact")]
	private AstParserRuleReturnScope<object, IToken> fact()
	{
		EnterRule_fact();
		EnterRule("fact", 8);
		TraceIn("fact", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MINUS18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom17 = default(AstParserRuleReturnScope<object, IToken>);

		object MINUS18_tree = default(object);
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_fact=new RewriteRuleSubtreeStream(adaptor,"rule fact");
		try { DebugEnterRule(GrammarFileName, "fact");
		DebugLocation(209, 1);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:210:2: ( atom | MINUS x= fact -> ^( NEGATIVE $x) )
			int alt10=2;
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==BREAK||LA10_0==FOR||(LA10_0>=ID && LA10_0<=IF)||LA10_0==INT||LA10_0==LET||LA10_0==LP||LA10_0==NIL||LA10_0==STRING||LA10_0==WHILE))
			{
				alt10 = 1;
			}
			else if ((LA10_0==MINUS))
			{
				alt10 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:210:4: atom
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(210, 4);
				PushFollow(Follow._atom_in_fact1601);
				atom17=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom17.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:211:4: MINUS x= fact
				{
				DebugLocation(211, 4);
				MINUS18=(IToken)Match(input,MINUS,Follow._MINUS_in_fact1606); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS18);

				DebugLocation(211, 12);
				PushFollow(Follow._fact_in_fact1612);
				x=fact();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_fact.Add(x.Tree);


				{
				// AST REWRITE
				// elements: x
				// token labels: 
				// rule labels: retval, x
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 211:19: -> ^( NEGATIVE $x)
				{
					DebugLocation(211, 22);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:211:22: ^( NEGATIVE $x)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(211, 24);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NEGATIVE, "NEGATIVE"), root_1);

					DebugLocation(211, 34);
					adaptor.AddChild(root_1, stream_x.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fact", 8);
			LeaveRule("fact", 8);
			LeaveRule_fact();
		}
		DebugLocation(212, 1);
		} finally { DebugExitRule(GrammarFileName, "fact"); }
		return retval;

	}
	// $ANTLR end "fact"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:214:1: atom : ( literals | call | loop | if_then_else | record | array_lvalue_assign | LP (exprs= expression_sequence )? RP -> ^( EXPRESSIONS_BLOCK ( $exprs)? ) | let_in_end | BREAK );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 9);
		TraceIn("atom", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LP25 = default(IToken);
		IToken RP26 = default(IToken);
		IToken BREAK28 = default(IToken);
		AstParserRuleReturnScope<object, IToken> exprs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> literals19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call20 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> loop21 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_then_else22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> record23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_lvalue_assign24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> let_in_end27 = default(AstParserRuleReturnScope<object, IToken>);

		object LP25_tree = default(object);
		object RP26_tree = default(object);
		object BREAK28_tree = default(object);
		RewriteRuleITokenStream stream_RP=new RewriteRuleITokenStream(adaptor,"token RP");
		RewriteRuleITokenStream stream_LP=new RewriteRuleITokenStream(adaptor,"token LP");
		RewriteRuleSubtreeStream stream_expression_sequence=new RewriteRuleSubtreeStream(adaptor,"rule expression_sequence");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(214, 8);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:215:2: ( literals | call | loop | if_then_else | record | array_lvalue_assign | LP (exprs= expression_sequence )? RP -> ^( EXPRESSIONS_BLOCK ( $exprs)? ) | let_in_end | BREAK )
			int alt12=9;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case INT:
			case NIL:
			case STRING:
				{
				alt12 = 1;
				}
				break;
			case ID:
				{
				switch (input.LA(2))
				{
				case LP:
					{
					alt12 = 2;
					}
					break;
				case LCB:
					{
					alt12 = 5;
					}
					break;
				case EOF:
				case AND:
				case ASSIGN:
				case COMMA:
				case DIV:
				case DO:
				case ELSE:
				case END:
				case EQ:
				case FUNCTION:
				case GETHAN:
				case GTHAN:
				case IN:
				case LETHAN:
				case LSB:
				case LTHAN:
				case MINUS:
				case NOTEQ:
				case OR:
				case PERIOD:
				case PLUS:
				case RCB:
				case RP:
				case RSB:
				case SEMI:
				case STAR:
				case THEN:
				case TO:
				case TYPE:
				case VAR:
					{
					alt12 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 12, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case FOR:
			case WHILE:
				{
				alt12 = 3;
				}
				break;
			case IF:
				{
				alt12 = 4;
				}
				break;
			case LP:
				{
				alt12 = 7;
				}
				break;
			case LET:
				{
				alt12 = 8;
				}
				break;
			case BREAK:
				{
				alt12 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:215:4: literals
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(215, 4);
				PushFollow(Follow._literals_in_atom1632);
				literals19=literals();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, literals19.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:216:4: call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(216, 4);
				PushFollow(Follow._call_in_atom1637);
				call20=call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, call20.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:217:4: loop
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(217, 4);
				PushFollow(Follow._loop_in_atom1642);
				loop21=loop();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, loop21.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:218:4: if_then_else
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(218, 4);
				PushFollow(Follow._if_then_else_in_atom1647);
				if_then_else22=if_then_else();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_then_else22.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:219:4: record
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(219, 4);
				PushFollow(Follow._record_in_atom1652);
				record23=record();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, record23.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:220:4: array_lvalue_assign
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(220, 4);
				PushFollow(Follow._array_lvalue_assign_in_atom1657);
				array_lvalue_assign24=array_lvalue_assign();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_lvalue_assign24.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:221:4: LP (exprs= expression_sequence )? RP
				{
				DebugLocation(221, 4);
				LP25=(IToken)Match(input,LP,Follow._LP_in_atom1662); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LP.Add(LP25);

				DebugLocation(221, 13);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:221:13: (exprs= expression_sequence )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==BREAK||LA11_0==FOR||(LA11_0>=ID && LA11_0<=IF)||LA11_0==INT||LA11_0==LET||LA11_0==LP||LA11_0==MINUS||LA11_0==NIL||LA11_0==STRING||LA11_0==WHILE))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:221:13: exprs= expression_sequence
					{
					DebugLocation(221, 13);
					PushFollow(Follow._expression_sequence_in_atom1668);
					exprs=expression_sequence();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression_sequence.Add(exprs.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(221, 36);
				RP26=(IToken)Match(input,RP,Follow._RP_in_atom1671); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RP.Add(RP26);



				{
				// AST REWRITE
				// elements: exprs
				// token labels: 
				// rule labels: retval, exprs
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_exprs=new RewriteRuleSubtreeStream(adaptor,"rule exprs",exprs!=null?exprs.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 221:39: -> ^( EXPRESSIONS_BLOCK ( $exprs)? )
				{
					DebugLocation(221, 42);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:221:42: ^( EXPRESSIONS_BLOCK ( $exprs)? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(221, 44);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSIONS_BLOCK, "EXPRESSIONS_BLOCK"), root_1);

					DebugLocation(221, 63);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:221:63: ( $exprs)?
					if (stream_exprs.HasNext)
					{
						DebugLocation(221, 63);
						adaptor.AddChild(root_1, stream_exprs.NextTree());

					}
					stream_exprs.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:222:4: let_in_end
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(222, 4);
				PushFollow(Follow._let_in_end_in_atom1686);
				let_in_end27=let_in_end();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, let_in_end27.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:223:4: BREAK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(223, 4);
				BREAK28=(IToken)Match(input,BREAK,Follow._BREAK_in_atom1691); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BREAK28_tree = (object)adaptor.Create(BREAK28);
				adaptor.AddChild(root_0, BREAK28_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 9);
			LeaveRule("atom", 9);
			LeaveRule_atom();
		}
		DebugLocation(223, 8);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_literals();
	partial void LeaveRule_literals();

	// $ANTLR start "literals"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:225:1: literals : ( INT | STRING | NIL );
	[GrammarRule("literals")]
	private AstParserRuleReturnScope<object, IToken> literals()
	{
		EnterRule_literals();
		EnterRule("literals", 10);
		TraceIn("literals", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set29 = default(IToken);

		object set29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "literals");
		DebugLocation(225, 21);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:226:2: ( INT | STRING | NIL )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(226, 2);

			set29=(IToken)input.LT(1);
			if (input.LA(1)==INT||input.LA(1)==NIL||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set29));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literals", 10);
			LeaveRule("literals", 10);
			LeaveRule_literals();
		}
		DebugLocation(226, 21);
		} finally { DebugExitRule(GrammarFileName, "literals"); }
		return retval;

	}
	// $ANTLR end "literals"

	partial void EnterRule_expression_list();
	partial void LeaveRule_expression_list();

	// $ANTLR start "expression_list"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:228:1: expression_list : expror ( COMMA ! expror )* ;
	[GrammarRule("expression_list")]
	private AstParserRuleReturnScope<object, IToken> expression_list()
	{
		EnterRule_expression_list();
		EnterRule("expression_list", 11);
		TraceIn("expression_list", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA31 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expror30 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expror32 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA31_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expression_list");
		DebugLocation(228, 26);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:229:2: ( expror ( COMMA ! expror )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:229:4: expror ( COMMA ! expror )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(229, 4);
			PushFollow(Follow._expror_in_expression_list1717);
			expror30=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror30.Tree);
			DebugLocation(229, 11);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:229:11: ( COMMA ! expror )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==COMMA))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:229:12: COMMA ! expror
					{
					DebugLocation(229, 17);
					COMMA31=(IToken)Match(input,COMMA,Follow._COMMA_in_expression_list1720); if (state.failed) return retval;
					DebugLocation(229, 19);
					PushFollow(Follow._expror_in_expression_list1723);
					expror32=expror();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expror32.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression_list", 11);
			LeaveRule("expression_list", 11);
			LeaveRule_expression_list();
		}
		DebugLocation(229, 26);
		} finally { DebugExitRule(GrammarFileName, "expression_list"); }
		return retval;

	}
	// $ANTLR end "expression_list"

	partial void EnterRule_call();
	partial void LeaveRule_call();

	// $ANTLR start "call"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:231:1: call : ID LP (fparams= expression_list )? RP -> ^( CALL ID ( $fparams)? ) ;
	[GrammarRule("call")]
	private AstParserRuleReturnScope<object, IToken> call()
	{
		EnterRule_call();
		EnterRule("call", 12);
		TraceIn("call", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID33 = default(IToken);
		IToken LP34 = default(IToken);
		IToken RP35 = default(IToken);
		AstParserRuleReturnScope<object, IToken> fparams = default(AstParserRuleReturnScope<object, IToken>);

		object ID33_tree = default(object);
		object LP34_tree = default(object);
		object RP35_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_RP=new RewriteRuleITokenStream(adaptor,"token RP");
		RewriteRuleITokenStream stream_LP=new RewriteRuleITokenStream(adaptor,"token LP");
		RewriteRuleSubtreeStream stream_expression_list=new RewriteRuleSubtreeStream(adaptor,"rule expression_list");
		try { DebugEnterRule(GrammarFileName, "call");
		DebugLocation(231, 62);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:232:2: ( ID LP (fparams= expression_list )? RP -> ^( CALL ID ( $fparams)? ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:232:4: ID LP (fparams= expression_list )? RP
			{
			DebugLocation(232, 4);
			ID33=(IToken)Match(input,ID,Follow._ID_in_call1734); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID33);

			DebugLocation(232, 7);
			LP34=(IToken)Match(input,LP,Follow._LP_in_call1736); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LP.Add(LP34);

			DebugLocation(232, 18);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:232:18: (fparams= expression_list )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==BREAK||LA14_0==FOR||(LA14_0>=ID && LA14_0<=IF)||LA14_0==INT||LA14_0==LET||LA14_0==LP||LA14_0==MINUS||LA14_0==NIL||LA14_0==STRING||LA14_0==WHILE))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:232:18: fparams= expression_list
				{
				DebugLocation(232, 18);
				PushFollow(Follow._expression_list_in_call1742);
				fparams=expression_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression_list.Add(fparams.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(232, 37);
			RP35=(IToken)Match(input,RP,Follow._RP_in_call1745); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RP.Add(RP35);



			{
			// AST REWRITE
			// elements: ID, fparams
			// token labels: 
			// rule labels: retval, fparams
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_fparams=new RewriteRuleSubtreeStream(adaptor,"rule fparams",fparams!=null?fparams.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 232:40: -> ^( CALL ID ( $fparams)? )
			{
				DebugLocation(232, 43);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:232:43: ^( CALL ID ( $fparams)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(232, 45);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(232, 50);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(232, 54);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:232:54: ( $fparams)?
				if (stream_fparams.HasNext)
				{
					DebugLocation(232, 54);
					adaptor.AddChild(root_1, stream_fparams.NextTree());

				}
				stream_fparams.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("call", 12);
			LeaveRule("call", 12);
			LeaveRule_call();
		}
		DebugLocation(232, 62);
		} finally { DebugExitRule(GrammarFileName, "call"); }
		return retval;

	}
	// $ANTLR end "call"

	partial void EnterRule_loop();
	partial void LeaveRule_loop();

	// $ANTLR start "loop"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:234:1: loop : ( for | while );
	[GrammarRule("loop")]
	private AstParserRuleReturnScope<object, IToken> loop()
	{
		EnterRule_loop();
		EnterRule("loop", 13);
		TraceIn("loop", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> for36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while37 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "loop");
		DebugLocation(234, 14);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:235:2: ( for | while )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==FOR))
			{
				alt15 = 1;
			}
			else if ((LA15_0==WHILE))
			{
				alt15 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:235:4: for
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(235, 4);
				PushFollow(Follow._for_in_loop1766);
				for36=@for();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for36.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:235:10: while
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(235, 10);
				PushFollow(Follow._while_in_loop1770);
				while37=@while();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while37.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("loop", 13);
			LeaveRule("loop", 13);
			LeaveRule_loop();
		}
		DebugLocation(235, 14);
		} finally { DebugExitRule(GrammarFileName, "loop"); }
		return retval;

	}
	// $ANTLR end "loop"

	partial void EnterRule_for();
	partial void LeaveRule_for();

	// $ANTLR start "for"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:237:1: for : FOR ^ ID ASSIGN ! expror TO ! expror DO ! expror ;
	[GrammarRule("for")]
	private AstParserRuleReturnScope<object, IToken> @for()
	{
		EnterRule_for();
		EnterRule("for", 14);
		TraceIn("for", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR38 = default(IToken);
		IToken ID39 = default(IToken);
		IToken ASSIGN40 = default(IToken);
		IToken TO42 = default(IToken);
		IToken DO44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expror41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expror43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expror45 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR38_tree = default(object);
		object ID39_tree = default(object);
		object ASSIGN40_tree = default(object);
		object TO42_tree = default(object);
		object DO44_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "for");
		DebugLocation(237, 47);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:238:2: ( FOR ^ ID ASSIGN ! expror TO ! expror DO ! expror )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:238:4: FOR ^ ID ASSIGN ! expror TO ! expror DO ! expror
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(238, 7);
			FOR38=(IToken)Match(input,FOR,Follow._FOR_in_for1779); if (state.failed) return retval;
			if (state.backtracking == 0) {
			FOR38_tree = (object)adaptor.Create(FOR38);
			root_0 = (object)adaptor.BecomeRoot(FOR38_tree, root_0);
			}
			DebugLocation(238, 9);
			ID39=(IToken)Match(input,ID,Follow._ID_in_for1782); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID39_tree = (object)adaptor.Create(ID39);
			adaptor.AddChild(root_0, ID39_tree);
			}
			DebugLocation(238, 18);
			ASSIGN40=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_for1784); if (state.failed) return retval;
			DebugLocation(238, 20);
			PushFollow(Follow._expror_in_for1787);
			expror41=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror41.Tree);
			DebugLocation(238, 29);
			TO42=(IToken)Match(input,TO,Follow._TO_in_for1789); if (state.failed) return retval;
			DebugLocation(238, 31);
			PushFollow(Follow._expror_in_for1792);
			expror43=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror43.Tree);
			DebugLocation(238, 40);
			DO44=(IToken)Match(input,DO,Follow._DO_in_for1794); if (state.failed) return retval;
			DebugLocation(238, 42);
			PushFollow(Follow._expror_in_for1797);
			expror45=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror45.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("for", 14);
			LeaveRule("for", 14);
			LeaveRule_for();
		}
		DebugLocation(238, 47);
		} finally { DebugExitRule(GrammarFileName, "for"); }
		return retval;

	}
	// $ANTLR end "for"

	partial void EnterRule_while();
	partial void LeaveRule_while();

	// $ANTLR start "while"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:240:1: while : WHILE ^ expror DO ! expror ;
	[GrammarRule("while")]
	private AstParserRuleReturnScope<object, IToken> @while()
	{
		EnterRule_while();
		EnterRule("while", 15);
		TraceIn("while", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE46 = default(IToken);
		IToken DO48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expror47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expror49 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE46_tree = default(object);
		object DO48_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "while");
		DebugLocation(240, 27);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:241:2: ( WHILE ^ expror DO ! expror )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:241:4: WHILE ^ expror DO ! expror
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(241, 9);
			WHILE46=(IToken)Match(input,WHILE,Follow._WHILE_in_while1806); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WHILE46_tree = (object)adaptor.Create(WHILE46);
			root_0 = (object)adaptor.BecomeRoot(WHILE46_tree, root_0);
			}
			DebugLocation(241, 11);
			PushFollow(Follow._expror_in_while1809);
			expror47=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror47.Tree);
			DebugLocation(241, 20);
			DO48=(IToken)Match(input,DO,Follow._DO_in_while1811); if (state.failed) return retval;
			DebugLocation(241, 22);
			PushFollow(Follow._expror_in_while1814);
			expror49=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expror49.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("while", 15);
			LeaveRule("while", 15);
			LeaveRule_while();
		}
		DebugLocation(241, 27);
		} finally { DebugExitRule(GrammarFileName, "while"); }
		return retval;

	}
	// $ANTLR end "while"

	partial void EnterRule_let_in_end();
	partial void LeaveRule_let_in_end();

	// $ANTLR start "let_in_end"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:243:1: let_in_end : LET decs= declaration_list IN (exps= expression_sequence )? END -> ^( LETINEND ^( BLOCK_DECLARATIONS $decs) ^( EXPRESSIONS_BLOCK ( $exps)? ) ) ;
	[GrammarRule("let_in_end")]
	private AstParserRuleReturnScope<object, IToken> let_in_end()
	{
		EnterRule_let_in_end();
		EnterRule("let_in_end", 16);
		TraceIn("let_in_end", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LET50 = default(IToken);
		IToken IN51 = default(IToken);
		IToken END52 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exps = default(AstParserRuleReturnScope<object, IToken>);

		object LET50_tree = default(object);
		object IN51_tree = default(object);
		object END52_tree = default(object);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleSubtreeStream stream_declaration_list=new RewriteRuleSubtreeStream(adaptor,"rule declaration_list");
		RewriteRuleSubtreeStream stream_expression_sequence=new RewriteRuleSubtreeStream(adaptor,"rule expression_sequence");
		try { DebugEnterRule(GrammarFileName, "let_in_end");
		DebugLocation(243, 136);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:2: ( LET decs= declaration_list IN (exps= expression_sequence )? END -> ^( LETINEND ^( BLOCK_DECLARATIONS $decs) ^( EXPRESSIONS_BLOCK ( $exps)? ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:4: LET decs= declaration_list IN (exps= expression_sequence )? END
			{
			DebugLocation(244, 4);
			LET50=(IToken)Match(input,LET,Follow._LET_in_let_in_end1823); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LET.Add(LET50);

			DebugLocation(244, 13);
			PushFollow(Follow._declaration_list_in_let_in_end1829);
			decs=declaration_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration_list.Add(decs.Tree);
			DebugLocation(244, 32);
			IN51=(IToken)Match(input,IN,Follow._IN_in_let_in_end1831); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IN.Add(IN51);

			DebugLocation(244, 40);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:40: (exps= expression_sequence )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==BREAK||LA16_0==FOR||(LA16_0>=ID && LA16_0<=IF)||LA16_0==INT||LA16_0==LET||LA16_0==LP||LA16_0==MINUS||LA16_0==NIL||LA16_0==STRING||LA16_0==WHILE))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:40: exps= expression_sequence
				{
				DebugLocation(244, 40);
				PushFollow(Follow._expression_sequence_in_let_in_end1837);
				exps=expression_sequence();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression_sequence.Add(exps.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(244, 63);
			END52=(IToken)Match(input,END,Follow._END_in_let_in_end1840); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END52);



			{
			// AST REWRITE
			// elements: exps, decs
			// token labels: 
			// rule labels: retval, decs, exps
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_decs=new RewriteRuleSubtreeStream(adaptor,"rule decs",decs!=null?decs.Tree:null);
			RewriteRuleSubtreeStream stream_exps=new RewriteRuleSubtreeStream(adaptor,"rule exps",exps!=null?exps.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 244:67: -> ^( LETINEND ^( BLOCK_DECLARATIONS $decs) ^( EXPRESSIONS_BLOCK ( $exps)? ) )
			{
				DebugLocation(244, 70);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:70: ^( LETINEND ^( BLOCK_DECLARATIONS $decs) ^( EXPRESSIONS_BLOCK ( $exps)? ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(244, 72);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LETINEND, "LETINEND"), root_1);

				DebugLocation(244, 81);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:81: ^( BLOCK_DECLARATIONS $decs)
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(244, 83);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK_DECLARATIONS, "BLOCK_DECLARATIONS"), root_2);

				DebugLocation(244, 103);
				adaptor.AddChild(root_2, stream_decs.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(244, 109);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:109: ^( EXPRESSIONS_BLOCK ( $exps)? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(244, 111);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPRESSIONS_BLOCK, "EXPRESSIONS_BLOCK"), root_2);

				DebugLocation(244, 130);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:244:130: ( $exps)?
				if (stream_exps.HasNext)
				{
					DebugLocation(244, 130);
					adaptor.AddChild(root_2, stream_exps.NextTree());

				}
				stream_exps.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("let_in_end", 16);
			LeaveRule("let_in_end", 16);
			LeaveRule_let_in_end();
		}
		DebugLocation(244, 136);
		} finally { DebugExitRule(GrammarFileName, "let_in_end"); }
		return retval;

	}
	// $ANTLR end "let_in_end"

	partial void EnterRule_if_then_else();
	partial void LeaveRule_if_then_else();

	// $ANTLR start "if_then_else"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:246:1: if_then_else : IF x= expror THEN y= expror ( options {greedy=true; } : ELSE z= expror -> ^( IF_THEN_ELSE $x $y $z) | -> ^( IF_THEN $x $y) ) ;
	[GrammarRule("if_then_else")]
	private AstParserRuleReturnScope<object, IToken> if_then_else()
	{
		EnterRule_if_then_else();
		EnterRule("if_then_else", 17);
		TraceIn("if_then_else", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF53 = default(IToken);
		IToken THEN54 = default(IToken);
		IToken ELSE55 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> y = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> z = default(AstParserRuleReturnScope<object, IToken>);

		object IF53_tree = default(object);
		object THEN54_tree = default(object);
		object ELSE55_tree = default(object);
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_expror=new RewriteRuleSubtreeStream(adaptor,"rule expror");
		try { DebugEnterRule(GrammarFileName, "if_then_else");
		DebugLocation(246, 129);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:2: ( IF x= expror THEN y= expror ( options {greedy=true; } : ELSE z= expror -> ^( IF_THEN_ELSE $x $y $z) | -> ^( IF_THEN $x $y) ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:4: IF x= expror THEN y= expror ( options {greedy=true; } : ELSE z= expror -> ^( IF_THEN_ELSE $x $y $z) | -> ^( IF_THEN $x $y) )
			{
			DebugLocation(247, 4);
			IF53=(IToken)Match(input,IF,Follow._IF_in_if_then_else1870); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF53);

			DebugLocation(247, 9);
			PushFollow(Follow._expror_in_if_then_else1876);
			x=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expror.Add(x.Tree);
			DebugLocation(247, 18);
			THEN54=(IToken)Match(input,THEN,Follow._THEN_in_if_then_else1878); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_THEN.Add(THEN54);

			DebugLocation(247, 25);
			PushFollow(Follow._expror_in_if_then_else1884);
			y=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expror.Add(y.Tree);
			DebugLocation(247, 34);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:34: ( options {greedy=true; } : ELSE z= expror -> ^( IF_THEN_ELSE $x $y $z) | -> ^( IF_THEN $x $y) )
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==ELSE))
			{
				alt17 = 1;
			}
			else if ((LA17_0==EOF||LA17_0==AND||LA17_0==COMMA||(LA17_0>=DIV && LA17_0<=DO)||(LA17_0>=END && LA17_0<=EQ)||LA17_0==FUNCTION||(LA17_0>=GETHAN && LA17_0<=GTHAN)||LA17_0==IN||LA17_0==LETHAN||(LA17_0>=LTHAN && LA17_0<=MINUS)||LA17_0==NOTEQ||LA17_0==OR||LA17_0==PLUS||LA17_0==RCB||(LA17_0>=RP && LA17_0<=STAR)||(LA17_0>=THEN && LA17_0<=TYPE)||LA17_0==VAR))
			{
				alt17 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:64: ELSE z= expror
				{
				DebugLocation(247, 64);
				ELSE55=(IToken)Match(input,ELSE,Follow._ELSE_in_if_then_else1900); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSE.Add(ELSE55);

				DebugLocation(247, 71);
				PushFollow(Follow._expror_in_if_then_else1906);
				z=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(z.Tree);


				{
				// AST REWRITE
				// elements: z, y, x
				// token labels: 
				// rule labels: retval, z, y, x
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_z=new RewriteRuleSubtreeStream(adaptor,"rule z",z!=null?z.Tree:null);
				RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
				RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 247:80: -> ^( IF_THEN_ELSE $x $y $z)
				{
					DebugLocation(247, 83);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:83: ^( IF_THEN_ELSE $x $y $z)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(247, 85);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN_ELSE, "IF_THEN_ELSE"), root_1);

					DebugLocation(247, 99);
					adaptor.AddChild(root_1, stream_x.NextTree());
					DebugLocation(247, 102);
					adaptor.AddChild(root_1, stream_y.NextTree());
					DebugLocation(247, 105);
					adaptor.AddChild(root_1, stream_z.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:110: 
				{

				{
				// AST REWRITE
				// elements: y, x
				// token labels: 
				// rule labels: retval, y, x
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,"rule y",y!=null?y.Tree:null);
				RewriteRuleSubtreeStream stream_x=new RewriteRuleSubtreeStream(adaptor,"rule x",x!=null?x.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 247:110: -> ^( IF_THEN $x $y)
				{
					DebugLocation(247, 113);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:247:113: ^( IF_THEN $x $y)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(247, 115);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF_THEN, "IF_THEN"), root_1);

					DebugLocation(247, 124);
					adaptor.AddChild(root_1, stream_x.NextTree());
					DebugLocation(247, 127);
					adaptor.AddChild(root_1, stream_y.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("if_then_else", 17);
			LeaveRule("if_then_else", 17);
			LeaveRule_if_then_else();
		}
		DebugLocation(247, 129);
		} finally { DebugExitRule(GrammarFileName, "if_then_else"); }
		return retval;

	}
	// $ANTLR end "if_then_else"

	partial void EnterRule_declaration_list();
	partial void LeaveRule_declaration_list();

	// $ANTLR start "declaration_list"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:249:1: declaration_list : ( types | variables | functions )+ ;
	[GrammarRule("declaration_list")]
	private AstParserRuleReturnScope<object, IToken> declaration_list()
	{
		EnterRule_declaration_list();
		EnterRule("declaration_list", 18);
		TraceIn("declaration_list", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> types56 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variables57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functions58 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration_list");
		DebugLocation(249, 35);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:250:2: ( ( types | variables | functions )+ )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:250:4: ( types | variables | functions )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(250, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:250:4: ( types | variables | functions )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=4;
				try { DebugEnterDecision(18, false);
				switch (input.LA(1))
				{
				case TYPE:
					{
					alt18 = 1;
					}
					break;
				case VAR:
					{
					alt18 = 2;
					}
					break;
				case FUNCTION:
					{
					alt18 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:250:5: types
					{
					DebugLocation(250, 5);
					PushFollow(Follow._types_in_declaration_list1946);
					types56=types();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, types56.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:250:13: variables
					{
					DebugLocation(250, 13);
					PushFollow(Follow._variables_in_declaration_list1950);
					variables57=variables();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variables57.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:250:25: functions
					{
					DebugLocation(250, 25);
					PushFollow(Follow._functions_in_declaration_list1954);
					functions58=functions();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, functions58.Tree);

					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_list", 18);
			LeaveRule("declaration_list", 18);
			LeaveRule_declaration_list();
		}
		DebugLocation(250, 35);
		} finally { DebugExitRule(GrammarFileName, "declaration_list"); }
		return retval;

	}
	// $ANTLR end "declaration_list"

	partial void EnterRule_types();
	partial void LeaveRule_types();

	// $ANTLR start "types"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:252:1: types : ( options {greedy=true; } : type_declaration )+ -> ^( TYPES_BLOCK ( type_declaration )+ ) ;
	[GrammarRule("types")]
	private AstParserRuleReturnScope<object, IToken> types()
	{
		EnterRule_types();
		EnterRule("types", 19);
		TraceIn("types", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_declaration59 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_type_declaration=new RewriteRuleSubtreeStream(adaptor,"rule type_declaration");
		try { DebugEnterRule(GrammarFileName, "types");
		DebugLocation(252, 85);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:253:2: ( ( options {greedy=true; } : type_declaration )+ -> ^( TYPES_BLOCK ( type_declaration )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:253:4: ( options {greedy=true; } : type_declaration )+
			{
			DebugLocation(253, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:253:4: ( options {greedy=true; } : type_declaration )+
			int cnt19=0;
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==TYPE))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:253:32: type_declaration
					{
					DebugLocation(253, 32);
					PushFollow(Follow._type_declaration_in_types1978);
					type_declaration59=type_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type_declaration.Add(type_declaration59.Tree);

					}
					break;

				default:
					if (cnt19 >= 1)
						goto loop19;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee19 = new EarlyExitException( 19, input );
					DebugRecognitionException(eee19);
					throw eee19;
				}
				cnt19++;
			}
			loop19:
				;

			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: type_declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 253:51: -> ^( TYPES_BLOCK ( type_declaration )+ )
			{
				DebugLocation(253, 54);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:253:54: ^( TYPES_BLOCK ( type_declaration )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(253, 56);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPES_BLOCK, "TYPES_BLOCK"), root_1);

				DebugLocation(253, 68);
				if (!(stream_type_declaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_type_declaration.HasNext )
				{
					DebugLocation(253, 68);
					adaptor.AddChild(root_1, stream_type_declaration.NextTree());

				}
				stream_type_declaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("types", 19);
			LeaveRule("types", 19);
			LeaveRule_types();
		}
		DebugLocation(253, 85);
		} finally { DebugExitRule(GrammarFileName, "types"); }
		return retval;

	}
	// $ANTLR end "types"

	partial void EnterRule_variables();
	partial void LeaveRule_variables();

	// $ANTLR start "variables"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:255:1: variables : ( options {greedy=true; } : variable_declaration )+ -> ^( VARIABLES_BLOCK ( variable_declaration )+ ) ;
	[GrammarRule("variables")]
	private AstParserRuleReturnScope<object, IToken> variables()
	{
		EnterRule_variables();
		EnterRule("variables", 20);
		TraceIn("variables", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> variable_declaration60 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_variable_declaration=new RewriteRuleSubtreeStream(adaptor,"rule variable_declaration");
		try { DebugEnterRule(GrammarFileName, "variables");
		DebugLocation(255, 97);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:256:2: ( ( options {greedy=true; } : variable_declaration )+ -> ^( VARIABLES_BLOCK ( variable_declaration )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:256:4: ( options {greedy=true; } : variable_declaration )+
			{
			DebugLocation(256, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:256:4: ( options {greedy=true; } : variable_declaration )+
			int cnt20=0;
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==VAR))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:256:32: variable_declaration
					{
					DebugLocation(256, 32);
					PushFollow(Follow._variable_declaration_in_variables2012);
					variable_declaration60=variable_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variable_declaration.Add(variable_declaration60.Tree);

					}
					break;

				default:
					if (cnt20 >= 1)
						goto loop20;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee20 = new EarlyExitException( 20, input );
					DebugRecognitionException(eee20);
					throw eee20;
				}
				cnt20++;
			}
			loop20:
				;

			} finally { DebugExitSubRule(20); }



			{
			// AST REWRITE
			// elements: variable_declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 256:55: -> ^( VARIABLES_BLOCK ( variable_declaration )+ )
			{
				DebugLocation(256, 58);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:256:58: ^( VARIABLES_BLOCK ( variable_declaration )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(256, 60);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARIABLES_BLOCK, "VARIABLES_BLOCK"), root_1);

				DebugLocation(256, 76);
				if (!(stream_variable_declaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variable_declaration.HasNext )
				{
					DebugLocation(256, 76);
					adaptor.AddChild(root_1, stream_variable_declaration.NextTree());

				}
				stream_variable_declaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variables", 20);
			LeaveRule("variables", 20);
			LeaveRule_variables();
		}
		DebugLocation(256, 97);
		} finally { DebugExitRule(GrammarFileName, "variables"); }
		return retval;

	}
	// $ANTLR end "variables"

	partial void EnterRule_functions();
	partial void LeaveRule_functions();

	// $ANTLR start "functions"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:258:1: functions : ( options {greedy=true; } : function_declaration )+ -> ^( FUNCTIONS_BLOCK ( function_declaration )+ ) ;
	[GrammarRule("functions")]
	private AstParserRuleReturnScope<object, IToken> functions()
	{
		EnterRule_functions();
		EnterRule("functions", 21);
		TraceIn("functions", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> function_declaration61 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_function_declaration=new RewriteRuleSubtreeStream(adaptor,"rule function_declaration");
		try { DebugEnterRule(GrammarFileName, "functions");
		DebugLocation(258, 97);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:259:2: ( ( options {greedy=true; } : function_declaration )+ -> ^( FUNCTIONS_BLOCK ( function_declaration )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:259:4: ( options {greedy=true; } : function_declaration )+
			{
			DebugLocation(259, 4);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:259:4: ( options {greedy=true; } : function_declaration )+
			int cnt21=0;
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==FUNCTION))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:259:32: function_declaration
					{
					DebugLocation(259, 32);
					PushFollow(Follow._function_declaration_in_functions2046);
					function_declaration61=function_declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_declaration.Add(function_declaration61.Tree);

					}
					break;

				default:
					if (cnt21 >= 1)
						goto loop21;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee21 = new EarlyExitException( 21, input );
					DebugRecognitionException(eee21);
					throw eee21;
				}
				cnt21++;
			}
			loop21:
				;

			} finally { DebugExitSubRule(21); }



			{
			// AST REWRITE
			// elements: function_declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 259:55: -> ^( FUNCTIONS_BLOCK ( function_declaration )+ )
			{
				DebugLocation(259, 58);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:259:58: ^( FUNCTIONS_BLOCK ( function_declaration )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(259, 60);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTIONS_BLOCK, "FUNCTIONS_BLOCK"), root_1);

				DebugLocation(259, 76);
				if (!(stream_function_declaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_function_declaration.HasNext )
				{
					DebugLocation(259, 76);
					adaptor.AddChild(root_1, stream_function_declaration.NextTree());

				}
				stream_function_declaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functions", 21);
			LeaveRule("functions", 21);
			LeaveRule_functions();
		}
		DebugLocation(259, 97);
		} finally { DebugExitRule(GrammarFileName, "functions"); }
		return retval;

	}
	// $ANTLR end "functions"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();

	// $ANTLR start "type_declaration"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:261:1: type_declaration : TYPE id= ID EQ (type_id= ID -> ^( TYPE_DECLARATION $id ^( ALIAS_TYPE $type_id) ) | ARRAY OF type_id= ID -> ^( TYPE_DECLARATION $id ^( ARRAY_TYPE $type_id) ) | LCB (fields= type_fields )? RCB -> ^( TYPE_DECLARATION $id ^( RECORD_TYPE ( $fields)? ) ) ) ;
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<object, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 22);
		TraceIn("type_declaration", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken type_id = default(IToken);
		IToken TYPE62 = default(IToken);
		IToken EQ63 = default(IToken);
		IToken ARRAY64 = default(IToken);
		IToken OF65 = default(IToken);
		IToken LCB66 = default(IToken);
		IToken RCB67 = default(IToken);
		AstParserRuleReturnScope<object, IToken> fields = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object type_id_tree = default(object);
		object TYPE62_tree = default(object);
		object EQ63_tree = default(object);
		object ARRAY64_tree = default(object);
		object OF65_tree = default(object);
		object LCB66_tree = default(object);
		object RCB67_tree = default(object);
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_RCB=new RewriteRuleITokenStream(adaptor,"token RCB");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_LCB=new RewriteRuleITokenStream(adaptor,"token LCB");
		RewriteRuleITokenStream stream_ARRAY=new RewriteRuleITokenStream(adaptor,"token ARRAY");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(261, 2);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:262:2: ( TYPE id= ID EQ (type_id= ID -> ^( TYPE_DECLARATION $id ^( ALIAS_TYPE $type_id) ) | ARRAY OF type_id= ID -> ^( TYPE_DECLARATION $id ^( ARRAY_TYPE $type_id) ) | LCB (fields= type_fields )? RCB -> ^( TYPE_DECLARATION $id ^( RECORD_TYPE ( $fields)? ) ) ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:262:4: TYPE id= ID EQ (type_id= ID -> ^( TYPE_DECLARATION $id ^( ALIAS_TYPE $type_id) ) | ARRAY OF type_id= ID -> ^( TYPE_DECLARATION $id ^( ARRAY_TYPE $type_id) ) | LCB (fields= type_fields )? RCB -> ^( TYPE_DECLARATION $id ^( RECORD_TYPE ( $fields)? ) ) )
			{
			DebugLocation(262, 4);
			TYPE62=(IToken)Match(input,TYPE,Follow._TYPE_in_type_declaration2066); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPE.Add(TYPE62);

			DebugLocation(262, 12);
			id=(IToken)Match(input,ID,Follow._ID_in_type_declaration2072); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(id);

			DebugLocation(262, 17);
			EQ63=(IToken)Match(input,EQ,Follow._EQ_in_type_declaration2074); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ63);

			DebugLocation(263, 2);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:263:2: (type_id= ID -> ^( TYPE_DECLARATION $id ^( ALIAS_TYPE $type_id) ) | ARRAY OF type_id= ID -> ^( TYPE_DECLARATION $id ^( ARRAY_TYPE $type_id) ) | LCB (fields= type_fields )? RCB -> ^( TYPE_DECLARATION $id ^( RECORD_TYPE ( $fields)? ) ) )
			int alt23=3;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt23 = 1;
				}
				break;
			case ARRAY:
				{
				alt23 = 2;
				}
				break;
			case LCB:
				{
				alt23 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:263:4: type_id= ID
				{
				DebugLocation(263, 12);
				type_id=(IToken)Match(input,ID,Follow._ID_in_type_declaration2083); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(type_id);



				{
				// AST REWRITE
				// elements: type_id, id
				// token labels: id, type_id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 263:34: -> ^( TYPE_DECLARATION $id ^( ALIAS_TYPE $type_id) )
				{
					DebugLocation(263, 37);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:263:37: ^( TYPE_DECLARATION $id ^( ALIAS_TYPE $type_id) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(263, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECLARATION, "TYPE_DECLARATION"), root_1);

					DebugLocation(263, 57);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(263, 60);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:263:60: ^( ALIAS_TYPE $type_id)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(263, 62);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ALIAS_TYPE, "ALIAS_TYPE"), root_2);

					DebugLocation(263, 74);
					adaptor.AddChild(root_2, stream_type_id.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:264:4: ARRAY OF type_id= ID
				{
				DebugLocation(264, 4);
				ARRAY64=(IToken)Match(input,ARRAY,Follow._ARRAY_in_type_declaration2121); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARRAY.Add(ARRAY64);

				DebugLocation(264, 10);
				OF65=(IToken)Match(input,OF,Follow._OF_in_type_declaration2123); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OF.Add(OF65);

				DebugLocation(264, 21);
				type_id=(IToken)Match(input,ID,Follow._ID_in_type_declaration2129); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(type_id);



				{
				// AST REWRITE
				// elements: id, type_id
				// token labels: id, type_id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 264:34: -> ^( TYPE_DECLARATION $id ^( ARRAY_TYPE $type_id) )
				{
					DebugLocation(264, 37);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:264:37: ^( TYPE_DECLARATION $id ^( ARRAY_TYPE $type_id) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(264, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECLARATION, "TYPE_DECLARATION"), root_1);

					DebugLocation(264, 57);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(264, 60);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:264:60: ^( ARRAY_TYPE $type_id)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(264, 62);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_TYPE, "ARRAY_TYPE"), root_2);

					DebugLocation(264, 74);
					adaptor.AddChild(root_2, stream_type_id.NextNode());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:265:4: LCB (fields= type_fields )? RCB
				{
				DebugLocation(265, 4);
				LCB66=(IToken)Match(input,LCB,Follow._LCB_in_type_declaration2158); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LCB.Add(LCB66);

				DebugLocation(265, 15);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:265:15: (fields= type_fields )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==ID))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:265:15: fields= type_fields
					{
					DebugLocation(265, 15);
					PushFollow(Follow._type_fields_in_type_declaration2164);
					fields=type_fields();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type_fields.Add(fields.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(265, 30);
				RCB67=(IToken)Match(input,RCB,Follow._RCB_in_type_declaration2167); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RCB.Add(RCB67);



				{
				// AST REWRITE
				// elements: fields, id
				// token labels: id
				// rule labels: retval, fields
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_fields=new RewriteRuleSubtreeStream(adaptor,"rule fields",fields!=null?fields.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 265:34: -> ^( TYPE_DECLARATION $id ^( RECORD_TYPE ( $fields)? ) )
				{
					DebugLocation(265, 37);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:265:37: ^( TYPE_DECLARATION $id ^( RECORD_TYPE ( $fields)? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(265, 39);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECLARATION, "TYPE_DECLARATION"), root_1);

					DebugLocation(265, 57);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(265, 60);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:265:60: ^( RECORD_TYPE ( $fields)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(265, 62);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_TYPE, "RECORD_TYPE"), root_2);

					DebugLocation(265, 75);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:265:75: ( $fields)?
					if (stream_fields.HasNext)
					{
						DebugLocation(265, 75);
						adaptor.AddChild(root_2, stream_fields.NextTree());

					}
					stream_fields.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_declaration", 22);
			LeaveRule("type_declaration", 22);
			LeaveRule_type_declaration();
		}
		DebugLocation(266, 2);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_field_type();
	partial void LeaveRule_field_type();

	// $ANTLR start "field_type"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:268:1: field_type : pname= ID COLON ptype= ID -> ^( FIELD_TYPE $pname $ptype) ;
	[GrammarRule("field_type")]
	private AstParserRuleReturnScope<object, IToken> field_type()
	{
		EnterRule_field_type();
		EnterRule("field_type", 23);
		TraceIn("field_type", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken pname = default(IToken);
		IToken ptype = default(IToken);
		IToken COLON68 = default(IToken);

		object pname_tree = default(object);
		object ptype_tree = default(object);
		object COLON68_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "field_type");
		DebugLocation(268, 61);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:269:2: (pname= ID COLON ptype= ID -> ^( FIELD_TYPE $pname $ptype) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:269:4: pname= ID COLON ptype= ID
			{
			DebugLocation(269, 10);
			pname=(IToken)Match(input,ID,Follow._ID_in_field_type2200); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(pname);

			DebugLocation(269, 15);
			COLON68=(IToken)Match(input,COLON,Follow._COLON_in_field_type2202); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON68);

			DebugLocation(269, 27);
			ptype=(IToken)Match(input,ID,Follow._ID_in_field_type2208); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ptype);



			{
			// AST REWRITE
			// elements: pname, ptype
			// token labels: pname, ptype
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_pname=new RewriteRuleITokenStream(adaptor,"token pname",pname);
			RewriteRuleITokenStream stream_ptype=new RewriteRuleITokenStream(adaptor,"token ptype",ptype);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 269:32: -> ^( FIELD_TYPE $pname $ptype)
			{
				DebugLocation(269, 35);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:269:35: ^( FIELD_TYPE $pname $ptype)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(269, 37);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_TYPE, "FIELD_TYPE"), root_1);

				DebugLocation(269, 49);
				adaptor.AddChild(root_1, stream_pname.NextNode());
				DebugLocation(269, 56);
				adaptor.AddChild(root_1, stream_ptype.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_type", 23);
			LeaveRule("field_type", 23);
			LeaveRule_field_type();
		}
		DebugLocation(269, 61);
		} finally { DebugExitRule(GrammarFileName, "field_type"); }
		return retval;

	}
	// $ANTLR end "field_type"

	partial void EnterRule_field_value();
	partial void LeaveRule_field_value();

	// $ANTLR start "field_value"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:271:1: field_value : name= ID EQ value= expror -> ^( FIELD_VALUE $name $value) ;
	[GrammarRule("field_value")]
	private AstParserRuleReturnScope<object, IToken> field_value()
	{
		EnterRule_field_value();
		EnterRule("field_value", 24);
		TraceIn("field_value", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken name = default(IToken);
		IToken EQ69 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value = default(AstParserRuleReturnScope<object, IToken>);

		object name_tree = default(object);
		object EQ69_tree = default(object);
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_expror=new RewriteRuleSubtreeStream(adaptor,"rule expror");
		try { DebugEnterRule(GrammarFileName, "field_value");
		DebugLocation(271, 61);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:272:2: (name= ID EQ value= expror -> ^( FIELD_VALUE $name $value) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:272:4: name= ID EQ value= expror
			{
			DebugLocation(272, 9);
			name=(IToken)Match(input,ID,Follow._ID_in_field_value2233); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(name);

			DebugLocation(272, 14);
			EQ69=(IToken)Match(input,EQ,Follow._EQ_in_field_value2235); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ69);

			DebugLocation(272, 23);
			PushFollow(Follow._expror_in_field_value2241);
			value=expror();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expror.Add(value.Tree);


			{
			// AST REWRITE
			// elements: name, value
			// token labels: name
			// rule labels: retval, value
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_name=new RewriteRuleITokenStream(adaptor,"token name",name);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value",value!=null?value.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 272:32: -> ^( FIELD_VALUE $name $value)
			{
				DebugLocation(272, 35);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:272:35: ^( FIELD_VALUE $name $value)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(272, 37);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_VALUE, "FIELD_VALUE"), root_1);

				DebugLocation(272, 50);
				adaptor.AddChild(root_1, stream_name.NextNode());
				DebugLocation(272, 56);
				adaptor.AddChild(root_1, stream_value.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_value", 24);
			LeaveRule("field_value", 24);
			LeaveRule_field_value();
		}
		DebugLocation(272, 61);
		} finally { DebugExitRule(GrammarFileName, "field_value"); }
		return retval;

	}
	// $ANTLR end "field_value"

	partial void EnterRule_type_fields();
	partial void LeaveRule_type_fields();

	// $ANTLR start "type_fields"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:274:1: type_fields : field_type ( COMMA ! field_type )* ;
	[GrammarRule("type_fields")]
	private AstParserRuleReturnScope<object, IToken> type_fields()
	{
		EnterRule_type_fields();
		EnterRule("type_fields", 25);
		TraceIn("type_fields", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA71 = default(IToken);
		AstParserRuleReturnScope<object, IToken> field_type70 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> field_type72 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA71_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_fields");
		DebugLocation(274, 35);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:275:2: ( field_type ( COMMA ! field_type )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:275:4: field_type ( COMMA ! field_type )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(275, 4);
			PushFollow(Follow._field_type_in_type_fields2262);
			field_type70=field_type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, field_type70.Tree);
			DebugLocation(275, 15);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:275:15: ( COMMA ! field_type )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==COMMA))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:275:16: COMMA ! field_type
					{
					DebugLocation(275, 21);
					COMMA71=(IToken)Match(input,COMMA,Follow._COMMA_in_type_fields2265); if (state.failed) return retval;
					DebugLocation(275, 23);
					PushFollow(Follow._field_type_in_type_fields2268);
					field_type72=field_type();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, field_type72.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_fields", 25);
			LeaveRule("type_fields", 25);
			LeaveRule_type_fields();
		}
		DebugLocation(275, 35);
		} finally { DebugExitRule(GrammarFileName, "type_fields"); }
		return retval;

	}
	// $ANTLR end "type_fields"

	partial void EnterRule_value_fields();
	partial void LeaveRule_value_fields();

	// $ANTLR start "value_fields"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:277:1: value_fields : field_value ( COMMA ! value_fields )? ;
	[GrammarRule("value_fields")]
	private AstParserRuleReturnScope<object, IToken> value_fields()
	{
		EnterRule_value_fields();
		EnterRule("value_fields", 26);
		TraceIn("value_fields", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA74 = default(IToken);
		AstParserRuleReturnScope<object, IToken> field_value73 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value_fields75 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA74_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_fields");
		DebugLocation(277, 37);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:278:2: ( field_value ( COMMA ! value_fields )? )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:278:4: field_value ( COMMA ! value_fields )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(278, 4);
			PushFollow(Follow._field_value_in_value_fields2280);
			field_value73=field_value();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, field_value73.Tree);
			DebugLocation(278, 16);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:278:16: ( COMMA ! value_fields )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==COMMA))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:278:17: COMMA ! value_fields
				{
				DebugLocation(278, 22);
				COMMA74=(IToken)Match(input,COMMA,Follow._COMMA_in_value_fields2283); if (state.failed) return retval;
				DebugLocation(278, 24);
				PushFollow(Follow._value_fields_in_value_fields2286);
				value_fields75=value_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, value_fields75.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_fields", 26);
			LeaveRule("value_fields", 26);
			LeaveRule_value_fields();
		}
		DebugLocation(278, 37);
		} finally { DebugExitRule(GrammarFileName, "value_fields"); }
		return retval;

	}
	// $ANTLR end "value_fields"

	partial void EnterRule_variable_declaration();
	partial void LeaveRule_variable_declaration();

	// $ANTLR start "variable_declaration"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:280:1: variable_declaration : VAR id= ID ( ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value) | COLON type_id= ID ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value $type_id) ) ;
	[GrammarRule("variable_declaration")]
	private AstParserRuleReturnScope<object, IToken> variable_declaration()
	{
		EnterRule_variable_declaration();
		EnterRule("variable_declaration", 27);
		TraceIn("variable_declaration", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken type_id = default(IToken);
		IToken VAR76 = default(IToken);
		IToken ASSIGN77 = default(IToken);
		IToken COLON78 = default(IToken);
		IToken ASSIGN79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object type_id_tree = default(object);
		object VAR76_tree = default(object);
		object ASSIGN77_tree = default(object);
		object COLON78_tree = default(object);
		object ASSIGN79_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expror=new RewriteRuleSubtreeStream(adaptor,"rule expror");
		try { DebugEnterRule(GrammarFileName, "variable_declaration");
		DebugLocation(280, 2);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:281:2: ( VAR id= ID ( ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value) | COLON type_id= ID ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value $type_id) ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:281:4: VAR id= ID ( ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value) | COLON type_id= ID ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value $type_id) )
			{
			DebugLocation(281, 4);
			VAR76=(IToken)Match(input,VAR,Follow._VAR_in_variable_declaration2297); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_VAR.Add(VAR76);

			DebugLocation(281, 11);
			id=(IToken)Match(input,ID,Follow._ID_in_variable_declaration2303); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(id);

			DebugLocation(282, 2);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:282:2: ( ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value) | COLON type_id= ID ASSIGN value= expror -> ^( VARIABLE_DECLARATION $id $value $type_id) )
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==ASSIGN))
			{
				alt26 = 1;
			}
			else if ((LA26_0==COLON))
			{
				alt26 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:282:4: ASSIGN value= expror
				{
				DebugLocation(282, 4);
				ASSIGN77=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variable_declaration2308); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN77);

				DebugLocation(282, 17);
				PushFollow(Follow._expror_in_variable_declaration2314);
				value=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(value.Tree);


				{
				// AST REWRITE
				// elements: id, value
				// token labels: id
				// rule labels: retval, value
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value",value!=null?value.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 282:45: -> ^( VARIABLE_DECLARATION $id $value)
				{
					DebugLocation(282, 48);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:282:48: ^( VARIABLE_DECLARATION $id $value)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(282, 50);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARIABLE_DECLARATION, "VARIABLE_DECLARATION"), root_1);

					DebugLocation(282, 72);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(282, 76);
					adaptor.AddChild(root_1, stream_value.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:283:4: COLON type_id= ID ASSIGN value= expror
				{
				DebugLocation(283, 4);
				COLON78=(IToken)Match(input,COLON,Follow._COLON_in_variable_declaration2350); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON78);

				DebugLocation(283, 18);
				type_id=(IToken)Match(input,ID,Follow._ID_in_variable_declaration2356); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(type_id);

				DebugLocation(283, 23);
				ASSIGN79=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variable_declaration2358); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN79);

				DebugLocation(283, 36);
				PushFollow(Follow._expror_in_variable_declaration2364);
				value=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(value.Tree);


				{
				// AST REWRITE
				// elements: id, type_id, value
				// token labels: id, type_id
				// rule labels: retval, value
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value",value!=null?value.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 283:45: -> ^( VARIABLE_DECLARATION $id $value $type_id)
				{
					DebugLocation(283, 48);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:283:48: ^( VARIABLE_DECLARATION $id $value $type_id)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(283, 50);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VARIABLE_DECLARATION, "VARIABLE_DECLARATION"), root_1);

					DebugLocation(283, 72);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(283, 76);
					adaptor.AddChild(root_1, stream_value.NextTree());
					DebugLocation(283, 83);
					adaptor.AddChild(root_1, stream_type_id.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration", 27);
			LeaveRule("variable_declaration", 27);
			LeaveRule_variable_declaration();
		}
		DebugLocation(284, 2);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration"); }
		return retval;

	}
	// $ANTLR end "variable_declaration"

	partial void EnterRule_function_declaration();
	partial void LeaveRule_function_declaration();

	// $ANTLR start "function_declaration"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:286:1: function_declaration : FUNCTION fname= ID LP (fparams= type_fields )? RP ( EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody) | COLON ftype= ID EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody $ftype) ) ;
	[GrammarRule("function_declaration")]
	private AstParserRuleReturnScope<object, IToken> function_declaration()
	{
		EnterRule_function_declaration();
		EnterRule("function_declaration", 28);
		TraceIn("function_declaration", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken fname = default(IToken);
		IToken ftype = default(IToken);
		IToken FUNCTION80 = default(IToken);
		IToken LP81 = default(IToken);
		IToken RP82 = default(IToken);
		IToken EQ83 = default(IToken);
		IToken COLON84 = default(IToken);
		IToken EQ85 = default(IToken);
		AstParserRuleReturnScope<object, IToken> fparams = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> fbody = default(AstParserRuleReturnScope<object, IToken>);

		object fname_tree = default(object);
		object ftype_tree = default(object);
		object FUNCTION80_tree = default(object);
		object LP81_tree = default(object);
		object RP82_tree = default(object);
		object EQ83_tree = default(object);
		object COLON84_tree = default(object);
		object EQ85_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_RP=new RewriteRuleITokenStream(adaptor,"token RP");
		RewriteRuleITokenStream stream_LP=new RewriteRuleITokenStream(adaptor,"token LP");
		RewriteRuleSubtreeStream stream_expror=new RewriteRuleSubtreeStream(adaptor,"rule expror");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		try { DebugEnterRule(GrammarFileName, "function_declaration");
		DebugLocation(286, 2);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:287:2: ( FUNCTION fname= ID LP (fparams= type_fields )? RP ( EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody) | COLON ftype= ID EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody $ftype) ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:287:4: FUNCTION fname= ID LP (fparams= type_fields )? RP ( EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody) | COLON ftype= ID EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody $ftype) )
			{
			DebugLocation(287, 4);
			FUNCTION80=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_function_declaration2392); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION80);

			DebugLocation(287, 19);
			fname=(IToken)Match(input,ID,Follow._ID_in_function_declaration2398); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(fname);

			DebugLocation(287, 24);
			LP81=(IToken)Match(input,LP,Follow._LP_in_function_declaration2400); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LP.Add(LP81);

			DebugLocation(287, 35);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:287:35: (fparams= type_fields )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==ID))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:287:35: fparams= type_fields
				{
				DebugLocation(287, 35);
				PushFollow(Follow._type_fields_in_function_declaration2406);
				fparams=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(fparams.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(287, 50);
			RP82=(IToken)Match(input,RP,Follow._RP_in_function_declaration2409); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RP.Add(RP82);

			DebugLocation(288, 2);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:288:2: ( EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody) | COLON ftype= ID EQ fbody= expror -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody $ftype) )
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==EQ))
			{
				alt28 = 1;
			}
			else if ((LA28_0==COLON))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:288:4: EQ fbody= expror
				{
				DebugLocation(288, 4);
				EQ83=(IToken)Match(input,EQ,Follow._EQ_in_function_declaration2414); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EQ.Add(EQ83);

				DebugLocation(288, 13);
				PushFollow(Follow._expror_in_function_declaration2420);
				fbody=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(fbody.Tree);


				{
				// AST REWRITE
				// elements: fbody, fparams, fname
				// token labels: fname
				// rule labels: retval, fbody, fparams
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_fname=new RewriteRuleITokenStream(adaptor,"token fname",fname);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_fbody=new RewriteRuleSubtreeStream(adaptor,"rule fbody",fbody!=null?fbody.Tree:null);
				RewriteRuleSubtreeStream stream_fparams=new RewriteRuleSubtreeStream(adaptor,"rule fparams",fparams!=null?fparams.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 288:31: -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody)
				{
					DebugLocation(288, 34);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:288:34: ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(288, 36);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_DECLARATION, "FUNCTION_DECLARATION"), root_1);

					DebugLocation(288, 58);
					adaptor.AddChild(root_1, stream_fname.NextNode());
					DebugLocation(288, 64);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:288:64: ^( PARAMETERS ( $fparams)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(288, 66);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAMETERS, "PARAMETERS"), root_2);

					DebugLocation(288, 78);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:288:78: ( $fparams)?
					if (stream_fparams.HasNext)
					{
						DebugLocation(288, 78);
						adaptor.AddChild(root_2, stream_fparams.NextTree());

					}
					stream_fparams.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(288, 89);
					adaptor.AddChild(root_1, stream_fbody.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:289:4: COLON ftype= ID EQ fbody= expror
				{
				DebugLocation(289, 4);
				COLON84=(IToken)Match(input,COLON,Follow._COLON_in_function_declaration2454); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON84);

				DebugLocation(289, 16);
				ftype=(IToken)Match(input,ID,Follow._ID_in_function_declaration2460); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ftype);

				DebugLocation(289, 21);
				EQ85=(IToken)Match(input,EQ,Follow._EQ_in_function_declaration2462); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EQ.Add(EQ85);

				DebugLocation(289, 30);
				PushFollow(Follow._expror_in_function_declaration2468);
				fbody=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(fbody.Tree);


				{
				// AST REWRITE
				// elements: fparams, ftype, fbody, fname
				// token labels: ftype, fname
				// rule labels: retval, fbody, fparams
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_ftype=new RewriteRuleITokenStream(adaptor,"token ftype",ftype);
				RewriteRuleITokenStream stream_fname=new RewriteRuleITokenStream(adaptor,"token fname",fname);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_fbody=new RewriteRuleSubtreeStream(adaptor,"rule fbody",fbody!=null?fbody.Tree:null);
				RewriteRuleSubtreeStream stream_fparams=new RewriteRuleSubtreeStream(adaptor,"rule fparams",fparams!=null?fparams.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 289:39: -> ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody $ftype)
				{
					DebugLocation(289, 42);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:289:42: ^( FUNCTION_DECLARATION $fname ^( PARAMETERS ( $fparams)? ) $fbody $ftype)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(289, 44);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_DECLARATION, "FUNCTION_DECLARATION"), root_1);

					DebugLocation(289, 66);
					adaptor.AddChild(root_1, stream_fname.NextNode());
					DebugLocation(289, 72);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:289:72: ^( PARAMETERS ( $fparams)? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(289, 74);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAMETERS, "PARAMETERS"), root_2);

					DebugLocation(289, 86);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:289:86: ( $fparams)?
					if (stream_fparams.HasNext)
					{
						DebugLocation(289, 86);
						adaptor.AddChild(root_2, stream_fparams.NextTree());

					}
					stream_fparams.Reset();

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(289, 97);
					adaptor.AddChild(root_1, stream_fbody.NextTree());
					DebugLocation(289, 104);
					adaptor.AddChild(root_1, stream_ftype.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(28); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function_declaration", 28);
			LeaveRule("function_declaration", 28);
			LeaveRule_function_declaration();
		}
		DebugLocation(290, 2);
		} finally { DebugExitRule(GrammarFileName, "function_declaration"); }
		return retval;

	}
	// $ANTLR end "function_declaration"

	partial void EnterRule_array_lvalue_assign();
	partial void LeaveRule_array_lvalue_assign();

	// $ANTLR start "array_lvalue_assign"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:292:1: array_lvalue_assign : ( ( ID LSB expror RSB OF )=> (id= ID LSB n= expror RSB OF exprs= expror -> ^( ARRAY $id $n $exprs) ) | lvalue ( ASSIGN ^ expror )? );
	[GrammarRule("array_lvalue_assign")]
	private AstParserRuleReturnScope<object, IToken> array_lvalue_assign()
	{
		EnterRule_array_lvalue_assign();
		EnterRule("array_lvalue_assign", 29);
		TraceIn("array_lvalue_assign", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken LSB86 = default(IToken);
		IToken RSB87 = default(IToken);
		IToken OF88 = default(IToken);
		IToken ASSIGN90 = default(IToken);
		AstParserRuleReturnScope<object, IToken> n = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> exprs = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expror91 = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object LSB86_tree = default(object);
		object RSB87_tree = default(object);
		object OF88_tree = default(object);
		object ASSIGN90_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_RSB=new RewriteRuleITokenStream(adaptor,"token RSB");
		RewriteRuleITokenStream stream_LSB=new RewriteRuleITokenStream(adaptor,"token LSB");
		RewriteRuleSubtreeStream stream_expror=new RewriteRuleSubtreeStream(adaptor,"rule expror");
		try { DebugEnterRule(GrammarFileName, "array_lvalue_assign");
		DebugLocation(292, 31);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:2: ( ( ID LSB expror RSB OF )=> (id= ID LSB n= expror RSB OF exprs= expror -> ^( ARRAY $id $n $exprs) ) | lvalue ( ASSIGN ^ expror )? )
			int alt30=2;
			try { DebugEnterDecision(30, false);
			int LA30_0 = input.LA(1);

			if ((LA30_0==ID))
			{
				int LA30_1 = input.LA(2);

				if ((LA30_1==LSB))
				{
					int LA30_2 = input.LA(3);

					if ((EvaluatePredicate(synpred1_Tiger_fragment)))
					{
						alt30 = 1;
					}
					else if ((true))
					{
						alt30 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 30, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA30_1==EOF||LA30_1==AND||LA30_1==ASSIGN||LA30_1==COMMA||(LA30_1>=DIV && LA30_1<=EQ)||LA30_1==FUNCTION||(LA30_1>=GETHAN && LA30_1<=GTHAN)||LA30_1==IN||LA30_1==LETHAN||(LA30_1>=LTHAN && LA30_1<=MINUS)||LA30_1==NOTEQ||LA30_1==OR||(LA30_1>=PERIOD && LA30_1<=PLUS)||LA30_1==RCB||(LA30_1>=RP && LA30_1<=STAR)||(LA30_1>=THEN && LA30_1<=TYPE)||LA30_1==VAR))
				{
					alt30 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 30, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:4: ( ID LSB expror RSB OF )=> (id= ID LSB n= expror RSB OF exprs= expror -> ^( ARRAY $id $n $exprs) )
				{
				DebugLocation(293, 30);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:30: (id= ID LSB n= expror RSB OF exprs= expror -> ^( ARRAY $id $n $exprs) )
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:31: id= ID LSB n= expror RSB OF exprs= expror
				{
				DebugLocation(293, 34);
				id=(IToken)Match(input,ID,Follow._ID_in_array_lvalue_assign2523); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(id);

				DebugLocation(293, 39);
				LSB86=(IToken)Match(input,LSB,Follow._LSB_in_array_lvalue_assign2525); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LSB.Add(LSB86);

				DebugLocation(293, 45);
				PushFollow(Follow._expror_in_array_lvalue_assign2531);
				n=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(n.Tree);
				DebugLocation(293, 54);
				RSB87=(IToken)Match(input,RSB,Follow._RSB_in_array_lvalue_assign2533); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RSB.Add(RSB87);

				DebugLocation(293, 58);
				OF88=(IToken)Match(input,OF,Follow._OF_in_array_lvalue_assign2535); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OF.Add(OF88);

				DebugLocation(293, 67);
				PushFollow(Follow._expror_in_array_lvalue_assign2541);
				exprs=expror();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expror.Add(exprs.Tree);


				{
				// AST REWRITE
				// elements: exprs, id, n
				// token labels: id
				// rule labels: retval, n, exprs
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,"rule n",n!=null?n.Tree:null);
				RewriteRuleSubtreeStream stream_exprs=new RewriteRuleSubtreeStream(adaptor,"rule exprs",exprs!=null?exprs.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 293:76: -> ^( ARRAY $id $n $exprs)
				{
					DebugLocation(293, 79);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:79: ^( ARRAY $id $n $exprs)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(293, 81);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY, "ARRAY"), root_1);

					DebugLocation(293, 88);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(293, 92);
					adaptor.AddChild(root_1, stream_n.NextTree());
					DebugLocation(293, 95);
					adaptor.AddChild(root_1, stream_exprs.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:294:6: lvalue ( ASSIGN ^ expror )?
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(294, 6);
				PushFollow(Follow._lvalue_in_array_lvalue_assign2564);
				lvalue89=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue89.Tree);
				DebugLocation(294, 13);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:294:13: ( ASSIGN ^ expror )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==ASSIGN))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:294:15: ASSIGN ^ expror
					{
					DebugLocation(294, 21);
					ASSIGN90=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_array_lvalue_assign2568); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ASSIGN90_tree = (object)adaptor.Create(ASSIGN90);
					root_0 = (object)adaptor.BecomeRoot(ASSIGN90_tree, root_0);
					}
					DebugLocation(294, 23);
					PushFollow(Follow._expror_in_array_lvalue_assign2571);
					expror91=expror();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expror91.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(29); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_lvalue_assign", 29);
			LeaveRule("array_lvalue_assign", 29);
			LeaveRule_array_lvalue_assign();
		}
		DebugLocation(294, 31);
		} finally { DebugExitRule(GrammarFileName, "array_lvalue_assign"); }
		return retval;

	}
	// $ANTLR end "array_lvalue_assign"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:296:1: lvalue : ID ( ( PERIOD ^ ID ) | ( LSB ^ expror RSB !) )* ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 30);
		TraceIn("lvalue", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID92 = default(IToken);
		IToken PERIOD93 = default(IToken);
		IToken ID94 = default(IToken);
		IToken LSB95 = default(IToken);
		IToken RSB97 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expror96 = default(AstParserRuleReturnScope<object, IToken>);

		object ID92_tree = default(object);
		object PERIOD93_tree = default(object);
		object ID94_tree = default(object);
		object LSB95_tree = default(object);
		object RSB97_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(296, 44);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:2: ( ID ( ( PERIOD ^ ID ) | ( LSB ^ expror RSB !) )* )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:4: ID ( ( PERIOD ^ ID ) | ( LSB ^ expror RSB !) )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(297, 4);
			ID92=(IToken)Match(input,ID,Follow._ID_in_lvalue2583); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID92_tree = (object)adaptor.Create(ID92);
			adaptor.AddChild(root_0, ID92_tree);
			}
			DebugLocation(297, 7);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:7: ( ( PERIOD ^ ID ) | ( LSB ^ expror RSB !) )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=3;
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==PERIOD))
				{
					alt31 = 1;
				}
				else if ((LA31_0==LSB))
				{
					alt31 = 2;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:9: ( PERIOD ^ ID )
					{
					DebugLocation(297, 9);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:9: ( PERIOD ^ ID )
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:10: PERIOD ^ ID
					{
					DebugLocation(297, 16);
					PERIOD93=(IToken)Match(input,PERIOD,Follow._PERIOD_in_lvalue2588); if (state.failed) return retval;
					if (state.backtracking == 0) {
					PERIOD93_tree = (object)adaptor.Create(PERIOD93);
					root_0 = (object)adaptor.BecomeRoot(PERIOD93_tree, root_0);
					}
					DebugLocation(297, 18);
					ID94=(IToken)Match(input,ID,Follow._ID_in_lvalue2591); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID94_tree = (object)adaptor.Create(ID94);
					adaptor.AddChild(root_0, ID94_tree);
					}

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:24: ( LSB ^ expror RSB !)
					{
					DebugLocation(297, 24);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:24: ( LSB ^ expror RSB !)
					DebugEnterAlt(1);
					// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:297:25: LSB ^ expror RSB !
					{
					DebugLocation(297, 28);
					LSB95=(IToken)Match(input,LSB,Follow._LSB_in_lvalue2597); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LSB95_tree = (object)adaptor.Create(LSB95);
					root_0 = (object)adaptor.BecomeRoot(LSB95_tree, root_0);
					}
					DebugLocation(297, 30);
					PushFollow(Follow._expror_in_lvalue2600);
					expror96=expror();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expror96.Tree);
					DebugLocation(297, 40);
					RSB97=(IToken)Match(input,RSB,Follow._RSB_in_lvalue2602); if (state.failed) return retval;

					}


					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 30);
			LeaveRule("lvalue", 30);
			LeaveRule_lvalue();
		}
		DebugLocation(297, 44);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_record();
	partial void LeaveRule_record();

	// $ANTLR start "record"
	// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:299:1: record : type_id= ID LCB (fields= value_fields )? RCB -> ^( RECORD $type_id ( $fields)? ) ;
	[GrammarRule("record")]
	private AstParserRuleReturnScope<object, IToken> record()
	{
		EnterRule_record();
		EnterRule("record", 31);
		TraceIn("record", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken type_id = default(IToken);
		IToken LCB98 = default(IToken);
		IToken RCB99 = default(IToken);
		AstParserRuleReturnScope<object, IToken> fields = default(AstParserRuleReturnScope<object, IToken>);

		object type_id_tree = default(object);
		object LCB98_tree = default(object);
		object RCB99_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_RCB=new RewriteRuleITokenStream(adaptor,"token RCB");
		RewriteRuleITokenStream stream_LCB=new RewriteRuleITokenStream(adaptor,"token LCB");
		RewriteRuleSubtreeStream stream_value_fields=new RewriteRuleSubtreeStream(adaptor,"rule value_fields");
		try { DebugEnterRule(GrammarFileName, "record");
		DebugLocation(299, 78);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:300:2: (type_id= ID LCB (fields= value_fields )? RCB -> ^( RECORD $type_id ( $fields)? ) )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:300:4: type_id= ID LCB (fields= value_fields )? RCB
			{
			DebugLocation(300, 12);
			type_id=(IToken)Match(input,ID,Follow._ID_in_record2620); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(type_id);

			DebugLocation(300, 17);
			LCB98=(IToken)Match(input,LCB,Follow._LCB_in_record2622); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCB.Add(LCB98);

			DebugLocation(300, 28);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:300:28: (fields= value_fields )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_0 = input.LA(1);

			if ((LA32_0==ID))
			{
				alt32 = 1;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:300:28: fields= value_fields
				{
				DebugLocation(300, 28);
				PushFollow(Follow._value_fields_in_record2628);
				fields=value_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_value_fields.Add(fields.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(32); }

			DebugLocation(300, 45);
			RCB99=(IToken)Match(input,RCB,Follow._RCB_in_record2632); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCB.Add(RCB99);



			{
			// AST REWRITE
			// elements: type_id, fields
			// token labels: type_id
			// rule labels: retval, fields
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_fields=new RewriteRuleSubtreeStream(adaptor,"rule fields",fields!=null?fields.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 300:49: -> ^( RECORD $type_id ( $fields)? )
			{
				DebugLocation(300, 52);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:300:52: ^( RECORD $type_id ( $fields)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(300, 54);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD, "RECORD"), root_1);

				DebugLocation(300, 62);
				adaptor.AddChild(root_1, stream_type_id.NextNode());
				DebugLocation(300, 71);
				// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:300:71: ( $fields)?
				if (stream_fields.HasNext)
				{
					DebugLocation(300, 71);
					adaptor.AddChild(root_1, stream_fields.NextTree());

				}
				stream_fields.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("record", 31);
			LeaveRule("record", 31);
			LeaveRule_record();
		}
		DebugLocation(300, 78);
		} finally { DebugExitRule(GrammarFileName, "record"); }
		return retval;

	}
	// $ANTLR end "record"

	partial void EnterRule_synpred1_Tiger_fragment();
	partial void LeaveRule_synpred1_Tiger_fragment();

	// $ANTLR start synpred1_Tiger
	public void synpred1_Tiger_fragment()
	{
		EnterRule_synpred1_Tiger_fragment();
		EnterRule("synpred1_Tiger_fragment", 32);
		TraceIn("synpred1_Tiger_fragment", 32);
		try
		{
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:4: ( ID LSB expror RSB OF )
			DebugEnterAlt(1);
			// C:\\Users\\leandro\\Desktop\\ANTLR Software\\TigerCompiler\\TigerCompiler\\Parsing\\Tiger.g:293:5: ID LSB expror RSB OF
			{
			DebugLocation(293, 5);
			Match(input,ID,Follow._ID_in_synpred1_Tiger2505); if (state.failed) return;
			DebugLocation(293, 8);
			Match(input,LSB,Follow._LSB_in_synpred1_Tiger2507); if (state.failed) return;
			DebugLocation(293, 12);
			PushFollow(Follow._expror_in_synpred1_Tiger2509);
			expror();
			PopFollow();
			if (state.failed) return;
			DebugLocation(293, 19);
			Match(input,RSB,Follow._RSB_in_synpred1_Tiger2511); if (state.failed) return;
			DebugLocation(293, 23);
			Match(input,OF,Follow._OF_in_synpred1_Tiger2513); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Tiger_fragment", 32);
			LeaveRule("synpred1_Tiger_fragment", 32);
			LeaveRule_synpred1_Tiger_fragment();
		}
	}
	// $ANTLR end synpred1_Tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expror_in_program1066 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program1068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expror_in_expression_sequence1086 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _SEMI_in_expression_sequence1089 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_expression_sequence1092 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _exprand_in_expror1108 = new BitSet(new ulong[]{0x4000000000002UL});
		public static readonly BitSet _OR_in_expror1128 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _exprand_in_expror1134 = new BitSet(new ulong[]{0x4000000000002UL});
		public static readonly BitSet _exprrel_in_exprand1162 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_exprand1182 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _exprrel_in_exprand1188 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _arith_in_exprrel1216 = new BitSet(new ulong[]{0x1084030100002UL});
		public static readonly BitSet _EQ_in_exprrel1240 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _arith_in_exprrel1250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOTEQ_in_exprrel1272 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _arith_in_exprrel1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LETHAN_in_exprrel1298 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _arith_in_exprrel1304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GETHAN_in_exprrel1322 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _arith_in_exprrel1328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LTHAN_in_exprrel1346 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _arith_in_exprrel1353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GTHAN_in_exprrel1372 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _arith_in_exprrel1379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_arith1417 = new BitSet(new ulong[]{0x40100000000002UL});
		public static readonly BitSet _MINUS_in_arith1442 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _term_in_arith1448 = new BitSet(new ulong[]{0x40100000000002UL});
		public static readonly BitSet _PLUS_in_arith1467 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _term_in_arith1474 = new BitSet(new ulong[]{0x40100000000002UL});
		public static readonly BitSet _fact_in_term1510 = new BitSet(new ulong[]{0x4000000000010002UL});
		public static readonly BitSet _STAR_in_term1536 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _fact_in_term1542 = new BitSet(new ulong[]{0x4000000000010002UL});
		public static readonly BitSet _DIV_in_term1562 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _fact_in_term1569 = new BitSet(new ulong[]{0x4000000000010002UL});
		public static readonly BitSet _atom_in_fact1601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_fact1606 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _fact_in_fact1612 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literals_in_atom1632 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _call_in_atom1637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _loop_in_atom1642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_then_else_in_atom1647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _record_in_atom1652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_lvalue_assign_in_atom1657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LP_in_atom1662 = new BitSet(new ulong[]{0x88009228C1000800UL,0x200UL});
		public static readonly BitSet _expression_sequence_in_atom1668 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _RP_in_atom1671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _let_in_end_in_atom1686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_atom1691 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expror_in_expression_list1717 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_expression_list1720 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_expression_list1723 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ID_in_call1734 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _LP_in_call1736 = new BitSet(new ulong[]{0x88009228C1000800UL,0x200UL});
		public static readonly BitSet _expression_list_in_call1742 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _RP_in_call1745 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_in_loop1766 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_in_loop1770 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_for1779 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_for1782 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_for1784 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_for1787 = new BitSet(new ulong[]{0x0UL,0x2UL});
		public static readonly BitSet _TO_in_for1789 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_for1792 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _DO_in_for1794 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_for1797 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_while1806 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_while1809 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _DO_in_while1811 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_while1814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_let_in_end1823 = new BitSet(new ulong[]{0x2000000UL,0x44UL});
		public static readonly BitSet _declaration_list_in_let_in_end1829 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _IN_in_let_in_end1831 = new BitSet(new ulong[]{0x80009228C1080800UL,0x200UL});
		public static readonly BitSet _expression_sequence_in_let_in_end1837 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _END_in_let_in_end1840 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_if_then_else1870 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_if_then_else1876 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _THEN_in_if_then_else1878 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_if_then_else1884 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ELSE_in_if_then_else1900 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_if_then_else1906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _types_in_declaration_list1946 = new BitSet(new ulong[]{0x2000002UL,0x44UL});
		public static readonly BitSet _variables_in_declaration_list1950 = new BitSet(new ulong[]{0x2000002UL,0x44UL});
		public static readonly BitSet _functions_in_declaration_list1954 = new BitSet(new ulong[]{0x2000002UL,0x44UL});
		public static readonly BitSet _type_declaration_in_types1978 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _variable_declaration_in_variables2012 = new BitSet(new ulong[]{0x2UL,0x40UL});
		public static readonly BitSet _function_declaration_in_functions2046 = new BitSet(new ulong[]{0x2000002UL});
		public static readonly BitSet _TYPE_in_type_declaration2066 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_type_declaration2072 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQ_in_type_declaration2074 = new BitSet(new ulong[]{0x1040000040UL});
		public static readonly BitSet _ID_in_type_declaration2083 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARRAY_in_type_declaration2121 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _OF_in_type_declaration2123 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_type_declaration2129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCB_in_type_declaration2158 = new BitSet(new ulong[]{0x100000040000000UL});
		public static readonly BitSet _type_fields_in_type_declaration2164 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RCB_in_type_declaration2167 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_field_type2200 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _COLON_in_field_type2202 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_field_type2208 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_field_value2233 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQ_in_field_value2235 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_field_value2241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _field_type_in_type_fields2262 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_type_fields2265 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _field_type_in_type_fields2268 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _field_value_in_value_fields2280 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_value_fields2283 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _value_fields_in_value_fields2286 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_variable_declaration2297 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_variable_declaration2303 = new BitSet(new ulong[]{0x2200UL});
		public static readonly BitSet _ASSIGN_in_variable_declaration2308 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_variable_declaration2314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_variable_declaration2350 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_variable_declaration2356 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ASSIGN_in_variable_declaration2358 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_variable_declaration2364 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_function_declaration2392 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_function_declaration2398 = new BitSet(new ulong[]{0x20000000000UL});
		public static readonly BitSet _LP_in_function_declaration2400 = new BitSet(new ulong[]{0x800000040000000UL});
		public static readonly BitSet _type_fields_in_function_declaration2406 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _RP_in_function_declaration2409 = new BitSet(new ulong[]{0x102000UL});
		public static readonly BitSet _EQ_in_function_declaration2414 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_function_declaration2420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_function_declaration2454 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_function_declaration2460 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _EQ_in_function_declaration2462 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_function_declaration2468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_array_lvalue_assign2523 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _LSB_in_array_lvalue_assign2525 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_array_lvalue_assign2531 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RSB_in_array_lvalue_assign2533 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _OF_in_array_lvalue_assign2535 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_array_lvalue_assign2541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_array_lvalue_assign2564 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ASSIGN_in_array_lvalue_assign2568 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_array_lvalue_assign2571 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_lvalue2583 = new BitSet(new ulong[]{0x20040000000002UL});
		public static readonly BitSet _PERIOD_in_lvalue2588 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _ID_in_lvalue2591 = new BitSet(new ulong[]{0x20040000000002UL});
		public static readonly BitSet _LSB_in_lvalue2597 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_lvalue2600 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RSB_in_lvalue2602 = new BitSet(new ulong[]{0x20040000000002UL});
		public static readonly BitSet _ID_in_record2620 = new BitSet(new ulong[]{0x1000000000UL});
		public static readonly BitSet _LCB_in_record2622 = new BitSet(new ulong[]{0x100000040000000UL});
		public static readonly BitSet _value_fields_in_record2628 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RCB_in_record2632 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred1_Tiger2505 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _LSB_in_synpred1_Tiger2507 = new BitSet(new ulong[]{0x80009228C1000800UL,0x200UL});
		public static readonly BitSet _expror_in_synpred1_Tiger2509 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _RSB_in_synpred1_Tiger2511 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _OF_in_synpred1_Tiger2513 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  TigerCompiler.Parsing 
